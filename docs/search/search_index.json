{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts!! Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 22/23. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Home"},{"location":"#benvinguts","text":"Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 22/23. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Benvinguts!!"},{"location":"about/","text":"Desenvolupament d'interf\u00e9cies Normativa Estatal -> RD: 450/2010 Auton\u00f2mica -> Curr\u00edculum CV: Ordre 58/2012 IES Jaume II \"El Just\" - Tavernes de la Valldigna Curs 2021-2022 Professor: Ferran Cunyat","title":"About"},{"location":"about/#desenvolupament-dinterfecies","text":"","title":"Desenvolupament d'interf\u00e9cies"},{"location":"about/#normativa","text":"Estatal -> RD: 450/2010 Auton\u00f2mica -> Curr\u00edculum CV: Ordre 58/2012","title":"Normativa"},{"location":"about/#ies-jaume-ii-el-just-tavernes-de-la-valldigna","text":"","title":"IES Jaume II \"El Just\" - Tavernes de la Valldigna"},{"location":"about/#curs-2021-2022","text":"Professor: Ferran Cunyat","title":"Curs 2021-2022"},{"location":"unitats/python/pr%C3%A0ctiques/1%20-%20PyGame/","text":"Introducci\u00f3 PyGame \u00e9s una llibreria de Python3 pensada per a desenvolupar de forma senzilla jocs amb Python. Anem a utilitzar-la per a desenvolupar un xicotet joc. Ser\u00e0 la primera activitat avaluable del curs. Instal\u00b7laci\u00f3 i configuraci\u00f3 El primer que farem \u00e9s activar el nostre entorn virtual de desenvolupament i instal\u00b7lar la llibreria pygame. Per a aix\u00f2 recordeu que utilitzarem venv tal com ve explicat a la teoria. Dins l'entorn virtual instal\u00b7lem pygame. Bash 1 2 $ source .venv/bin/activate ( .venv ) $ pip install pygame Hola m\u00f3n! del pygame Aquest programa crea una finestra, omple el fons de blanc i dibuixa un cercle blau al mig: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Simple pygame program # Import and initialize the pygame library import pygame pygame . init () # Set up the drawing window screen = pygame . display . set_mode ([ 500 , 500 ]) # Run until the user asks to quit running = True while running : # Did the user click the window close button? for event in pygame . event . get (): if event . type == pygame . QUIT : running = False # Fill the background with white screen . fill (( 255 , 255 , 255 )) # Draw a solid blue circle in the center pygame . draw . circle ( screen , ( 0 , 0 , 255 ), ( 250 , 250 ), 75 ) # Flip the display pygame . display . flip () enem # Done! Time to quit. pygame . quit () Fixem-nos en alguns punts: La l\u00ednia 8 configura la finestra de visualitzaci\u00f3 del programa, amb unes dimensions de 500x500 pixels. Les l\u00ednies 11 i 12 configuren un bucle de joc per controlar quan finalitza el programa. Les l\u00ednies 15 a 17 recullen i gestionen esdeveniments dins del bucle del joc. L'\u00fanic esdeveniment gestionat de moment \u00e9s pygame.QUIT, que es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. La l\u00ednia 20 omple la finestra d\u2019un color s\u00f2lid. screen.fill() accepta una llista o una tupla que especifica els valors RGB del color. (255, 255, 255), \u00e9s el color blanc. La l\u00ednia 23 dibuixa un cercle a la finestra, utilitzant els par\u00e0metres (finestra on dibuixar, color, posici\u00f3 central i radi) La l\u00ednia 26 actualitza el contingut de la pantalla, que de moment no canvia al llarg del temps. La l\u00ednia 29 ix del joc, sols s'executa quan ix del bucle per l'event QUIT. Aquesta \u00e9s la versi\u00f3 pygame de \"Hola, m\u00f3n\".","title":"Introducci\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/1%20-%20PyGame/#introduccio","text":"PyGame \u00e9s una llibreria de Python3 pensada per a desenvolupar de forma senzilla jocs amb Python. Anem a utilitzar-la per a desenvolupar un xicotet joc. Ser\u00e0 la primera activitat avaluable del curs.","title":"Introducci\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/1%20-%20PyGame/#installacio-i-configuracio","text":"El primer que farem \u00e9s activar el nostre entorn virtual de desenvolupament i instal\u00b7lar la llibreria pygame. Per a aix\u00f2 recordeu que utilitzarem venv tal com ve explicat a la teoria. Dins l'entorn virtual instal\u00b7lem pygame. Bash 1 2 $ source .venv/bin/activate ( .venv ) $ pip install pygame","title":"Instal\u00b7laci\u00f3 i configuraci\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/1%20-%20PyGame/#hola-mon-del-pygame","text":"Aquest programa crea una finestra, omple el fons de blanc i dibuixa un cercle blau al mig: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Simple pygame program # Import and initialize the pygame library import pygame pygame . init () # Set up the drawing window screen = pygame . display . set_mode ([ 500 , 500 ]) # Run until the user asks to quit running = True while running : # Did the user click the window close button? for event in pygame . event . get (): if event . type == pygame . QUIT : running = False # Fill the background with white screen . fill (( 255 , 255 , 255 )) # Draw a solid blue circle in the center pygame . draw . circle ( screen , ( 0 , 0 , 255 ), ( 250 , 250 ), 75 ) # Flip the display pygame . display . flip () enem # Done! Time to quit. pygame . quit () Fixem-nos en alguns punts: La l\u00ednia 8 configura la finestra de visualitzaci\u00f3 del programa, amb unes dimensions de 500x500 pixels. Les l\u00ednies 11 i 12 configuren un bucle de joc per controlar quan finalitza el programa. Les l\u00ednies 15 a 17 recullen i gestionen esdeveniments dins del bucle del joc. L'\u00fanic esdeveniment gestionat de moment \u00e9s pygame.QUIT, que es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. La l\u00ednia 20 omple la finestra d\u2019un color s\u00f2lid. screen.fill() accepta una llista o una tupla que especifica els valors RGB del color. (255, 255, 255), \u00e9s el color blanc. La l\u00ednia 23 dibuixa un cercle a la finestra, utilitzant els par\u00e0metres (finestra on dibuixar, color, posici\u00f3 central i radi) La l\u00ednia 26 actualitza el contingut de la pantalla, que de moment no canvia al llarg del temps. La l\u00ednia 29 ix del joc, sols s'executa quan ix del bucle per l'event QUIT. Aquesta \u00e9s la versi\u00f3 pygame de \"Hola, m\u00f3n\".","title":"Hola m\u00f3n! del pygame"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/","text":"Disseny del joc Una vegada vist els conceptes b\u00e0sics anem a desenvolupar un xicotet joc a mode d'exemple. L'objectiu del joc \u00e9s evitar obstacles que entren: El jugador comen\u00e7a a la part esquerra de la pantalla. Els obstacles entren a l'atzar per la dreta i es mouen a l'esquerra en l\u00ednia recta. El jugador pot moure's cap a l'esquerra, cap a la dreta, cap amunt o cap avall per evitar els obstacles. El jugador no pot ixir-se'n de la pantalla. El joc finalitza quan el jugador \u00e9s colpejat per un obstacle o quan l'usuari tanca la finestra. Mentre no es produisca a\u00e7\u00f2, el joc continua, pot ser infinit. Importem i inicialitzem el joc Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT ) # Initialize pygame pygame . init () Utilitzem les constants definides en locals per veure quina tecla s'ha apretat, o si s'ha pulsat sobre l'aspa de tancar el programa. Configurem la pantalla Python 1 2 3 4 5 6 7 # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) Definim una finestra \u00e9s de 800x600, utilitzant les constants SCREEN_WIDTH i SCREEN_HEIGHT. El m\u00e8tode ens torna una superf\u00edcie que representa les dimensions interiors de la finestra. Aquesta \u00e9s la part de la finestra que podem controlar, mentre que el sistema operatiu controla els l\u00edmits de la finestra i la barra de t\u00edtol. Si executeu aquest programa ara, apareixer\u00e0 una finestra que apareixer\u00e0 breument i desapareixer\u00e0 immediatament. Configuraci\u00f3 del bucle principal del joc Tots els jocs des de Pong fins a Fortnite utilitzen un bucle de joc per controlar-lo. Fa quatre coses molt importants: Processa l'entrada de l'usuari Actualitza l'estat de tots els objectes del joc Actualitza la pantalla i l'\u00e0udio Mant\u00e9 la velocitat del joc Tots els cicles del bucle del joc s\u2019anomenen fotogrames i, com m\u00e9s r\u00e0pid es facen les coses a cada cicle, m\u00e9s r\u00e0pid es desenvolupar\u00e0 el vostre joc. Els fotogrames continuen ocorrent fins que es compleix alguna condici\u00f3 per ixir del joc. Al vostre disseny, hi ha dues condicions que poden acabar amb el bucle del joc: El jugador xoca amb un obstacle. (M\u00e9s endavant, cobrir\u00e0 la detecci\u00f3 de col\u00b7lisions.) El jugador tanca la finestra (esdeveniment QUIT). El primer que fa el bucle del joc \u00e9s processar l'entrada de l'usuari per permetre al jugador moure's per la pantalla. Per tant, necessiteu alguna manera de capturar i processar una gran quantitat d\u2019informacions. Ho farem mitjan\u00e7ant el sistema d'esdeveniments pygame. Processament d'esdeveniments Pr\u00e9mer una tecla, moure el ratol\u00ed o el joystick s\u00f3n algunes de les maneres en qu\u00e8 un usuari pot proporcionar informaci\u00f3. Totes aquestes accions de l'usuari donen lloc a la generaci\u00f3 d'un esdeveniment i poden passar en qualsevol moment. Tots els esdeveniments de Pygame es col\u00b7loquen a la cua d'esdeveniments , la qual es pot accedir i manipular. El tractament que es fa dels esdeveniments s\u2019anomena gestor d\u2019esdeveniments. Tots els esdeveniments de Pygame tenen associat un tipus d'esdeveniment. Per al vostre joc, els tipus d\u2019esdeveniments en qu\u00e8 us centreu s\u00f3n les pulsacions de tecles i el tancament de la finestra. Els esdeveniments de premuda de tecles tenen el tipus d'esdeveniment KEYDOWN. L'esdeveniment de tancament de finestra t\u00e9 el tipus QUIT. Els diferents tipus d'esdeveniments tamb\u00e9 poden tenir associades altres dades. Per exemple, el tipus d'esdeveniment KEYDOWN tamb\u00e9 t\u00e9 una variable anomenada key per indicar quina tecla s'ha premut. Accediu a la llista de tots els esdeveniments actius a la cua trucant amb pygame.event.get() . A continuaci\u00f3, passeu per aquesta llista, inspeccioneu cada tipus d'esdeveniment i tracteu-los: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Variable to keep the main loop running running = True # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False Vegem m\u00e9s a fons aquest bucle principal del joc: S'estableix una variable de control per al bucle del joc. Per a ixir del bucle i del joc, hem d\u2019establir la variable running = False . Recorrem el gestor d'esdeveniments, recollint tots els esdeveniments que hi ha actualment a la cua d'esdeveniments. Si no hi ha esdeveniments, la llista est\u00e0 buida i el gestor no far\u00e0 res. Per a cada esdeveniment de la cua, comprovem el tipus. Si event.type == KEYDOWN , s'ha apretat alguna tecla. Si \u00e9s aix\u00ed, comprovem quina tecla s'ha apretat mirant l'atribut event.key . Si la clau \u00e9s la tecla Esc, indicada per K_ESCAPE, surt del bucle del joc configurant running = False. Es fa una comprovaci\u00f3 similar per al tipus d'esdeveniment QUIT . Aquest esdeveniment nom\u00e9s es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. L'usuari tamb\u00e9 pot utilitzar qualsevol altra acci\u00f3 del sistema operatiu per tancar la finestra. Quan afegiu aquestes l\u00ednies al codi anterior i l'executeu, veureu una finestra amb una pantalla en blanc o negre. La finestra no desapareixer\u00e0 fins que no premeu la tecla Esc tanqueu la finestra amb el ratol\u00ed o combinaci\u00f3 de tecles Alt + F4 . (Comproveu-ho, per\u00f2 recordeu afegir pygame.display.flip() per a que pinte la pantalla al bucle). Pintant objectes a la pantalla Al programa de mostra, hem dibuixat a la pantalla mitjan\u00e7ant dos m\u00e8todes: screen.fill() per omplir el fons pygame.draw.circle() per dibuixar un cercle Ara veurem una tercera manera de dibuixar a la pantalla: utilitzar una superf\u00edcie Surface . Una superf\u00edcie \u00e9s un objecte rectangular sobre el qual podem dibuixar, com un full de paper en blanc. La pantalla \u00e9s una superf\u00edcie i podeu crear els vostres propis objectes de superf\u00edcie separats de la pantalla. Vegem com funciona: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with white screen . fill (( 255 , 255 , 255 )) # Create a surface and pass in a tuple containing its length and width surf = pygame . Surface (( 50 , 50 )) # Give the surface a color to separate it from the background surf . fill (( 0 , 0 , 0 )) rect = surf . get_rect () A la primera l\u00ednia la pantalla s'omple de blanc. Despr\u00e9s es crea una nova superf\u00edcie de 50 p\u00edxels d'ample, 50 p\u00edxels d'al\u00e7ada i s'assigna a surf . Ara surf \u00e9s una superf\u00edcie igual que la pantalla principal i l'omplim de negre. Accedim al seu rectangle subjacentmitjan\u00e7ant get_rect() per poder-ho utilitzar posteriorment. \u00das de .blit () i .flip () El fet de crear una nova superf\u00edcie no \u00e9s suficient per veure-la a la pantalla. Per fer-ho, cal que col\u00b7loqueu la superf\u00edcie sobre una altra superf\u00edcie. El terme blit significa Block Transfer (Transfer\u00e8ncia de blocs) i .blit() \u00e9s la forma de copiar el contingut d\u2019una superf\u00edcie a una altra. Nom\u00e9s podeu copiar el contingut entre superf\u00edcies, per\u00f2 ja haviem dit que screen \u00e9s una superf\u00edcie. Vegem com dibuixem surf a la pantalla: Python 1 2 3 # This line says \"Draw surf onto the screen at the center\" screen . blit ( surf , ( SCREEN_WIDTH / 2 , SCREEN_HEIGHT / 2 )) pygame . display . flip () La funci\u00f3 blit pren dos arguments: 1. La superf\u00edcie a pintar 2. Les coordenades del v\u00e8rtex top-left Per tant si ho volem pintar exactament al centre de la pantalla hauriem de restar la seua amplada i altura respectivament: Python 1 2 3 4 5 6 7 8 9 # Put the center of surf at the center of the display surf_center = ( ( SCREEN_WIDTH - surf . get_width ()) / 2 , ( SCREEN_HEIGHT - surf . get_height ()) / 2 ) # Draw surf at the new coordinates screen . blit ( surf , surf_center ) pygame . display . flip () Recordeu fer la crida a la funci\u00f3 flip per a repintar el joc.","title":"Disseny del joc"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#disseny-del-joc","text":"Una vegada vist els conceptes b\u00e0sics anem a desenvolupar un xicotet joc a mode d'exemple. L'objectiu del joc \u00e9s evitar obstacles que entren: El jugador comen\u00e7a a la part esquerra de la pantalla. Els obstacles entren a l'atzar per la dreta i es mouen a l'esquerra en l\u00ednia recta. El jugador pot moure's cap a l'esquerra, cap a la dreta, cap amunt o cap avall per evitar els obstacles. El jugador no pot ixir-se'n de la pantalla. El joc finalitza quan el jugador \u00e9s colpejat per un obstacle o quan l'usuari tanca la finestra. Mentre no es produisca a\u00e7\u00f2, el joc continua, pot ser infinit.","title":"Disseny del joc"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#importem-i-inicialitzem-el-joc","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT ) # Initialize pygame pygame . init () Utilitzem les constants definides en locals per veure quina tecla s'ha apretat, o si s'ha pulsat sobre l'aspa de tancar el programa.","title":"Importem i inicialitzem el joc"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#configurem-la-pantalla","text":"Python 1 2 3 4 5 6 7 # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) Definim una finestra \u00e9s de 800x600, utilitzant les constants SCREEN_WIDTH i SCREEN_HEIGHT. El m\u00e8tode ens torna una superf\u00edcie que representa les dimensions interiors de la finestra. Aquesta \u00e9s la part de la finestra que podem controlar, mentre que el sistema operatiu controla els l\u00edmits de la finestra i la barra de t\u00edtol. Si executeu aquest programa ara, apareixer\u00e0 una finestra que apareixer\u00e0 breument i desapareixer\u00e0 immediatament.","title":"Configurem la pantalla"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#configuracio-del-bucle-principal-del-joc","text":"Tots els jocs des de Pong fins a Fortnite utilitzen un bucle de joc per controlar-lo. Fa quatre coses molt importants: Processa l'entrada de l'usuari Actualitza l'estat de tots els objectes del joc Actualitza la pantalla i l'\u00e0udio Mant\u00e9 la velocitat del joc Tots els cicles del bucle del joc s\u2019anomenen fotogrames i, com m\u00e9s r\u00e0pid es facen les coses a cada cicle, m\u00e9s r\u00e0pid es desenvolupar\u00e0 el vostre joc. Els fotogrames continuen ocorrent fins que es compleix alguna condici\u00f3 per ixir del joc. Al vostre disseny, hi ha dues condicions que poden acabar amb el bucle del joc: El jugador xoca amb un obstacle. (M\u00e9s endavant, cobrir\u00e0 la detecci\u00f3 de col\u00b7lisions.) El jugador tanca la finestra (esdeveniment QUIT). El primer que fa el bucle del joc \u00e9s processar l'entrada de l'usuari per permetre al jugador moure's per la pantalla. Per tant, necessiteu alguna manera de capturar i processar una gran quantitat d\u2019informacions. Ho farem mitjan\u00e7ant el sistema d'esdeveniments pygame.","title":"Configuraci\u00f3 del bucle principal del joc"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#processament-desdeveniments","text":"Pr\u00e9mer una tecla, moure el ratol\u00ed o el joystick s\u00f3n algunes de les maneres en qu\u00e8 un usuari pot proporcionar informaci\u00f3. Totes aquestes accions de l'usuari donen lloc a la generaci\u00f3 d'un esdeveniment i poden passar en qualsevol moment. Tots els esdeveniments de Pygame es col\u00b7loquen a la cua d'esdeveniments , la qual es pot accedir i manipular. El tractament que es fa dels esdeveniments s\u2019anomena gestor d\u2019esdeveniments. Tots els esdeveniments de Pygame tenen associat un tipus d'esdeveniment. Per al vostre joc, els tipus d\u2019esdeveniments en qu\u00e8 us centreu s\u00f3n les pulsacions de tecles i el tancament de la finestra. Els esdeveniments de premuda de tecles tenen el tipus d'esdeveniment KEYDOWN. L'esdeveniment de tancament de finestra t\u00e9 el tipus QUIT. Els diferents tipus d'esdeveniments tamb\u00e9 poden tenir associades altres dades. Per exemple, el tipus d'esdeveniment KEYDOWN tamb\u00e9 t\u00e9 una variable anomenada key per indicar quina tecla s'ha premut. Accediu a la llista de tots els esdeveniments actius a la cua trucant amb pygame.event.get() . A continuaci\u00f3, passeu per aquesta llista, inspeccioneu cada tipus d'esdeveniment i tracteu-los: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Variable to keep the main loop running running = True # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False Vegem m\u00e9s a fons aquest bucle principal del joc: S'estableix una variable de control per al bucle del joc. Per a ixir del bucle i del joc, hem d\u2019establir la variable running = False . Recorrem el gestor d'esdeveniments, recollint tots els esdeveniments que hi ha actualment a la cua d'esdeveniments. Si no hi ha esdeveniments, la llista est\u00e0 buida i el gestor no far\u00e0 res. Per a cada esdeveniment de la cua, comprovem el tipus. Si event.type == KEYDOWN , s'ha apretat alguna tecla. Si \u00e9s aix\u00ed, comprovem quina tecla s'ha apretat mirant l'atribut event.key . Si la clau \u00e9s la tecla Esc, indicada per K_ESCAPE, surt del bucle del joc configurant running = False. Es fa una comprovaci\u00f3 similar per al tipus d'esdeveniment QUIT . Aquest esdeveniment nom\u00e9s es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. L'usuari tamb\u00e9 pot utilitzar qualsevol altra acci\u00f3 del sistema operatiu per tancar la finestra. Quan afegiu aquestes l\u00ednies al codi anterior i l'executeu, veureu una finestra amb una pantalla en blanc o negre. La finestra no desapareixer\u00e0 fins que no premeu la tecla Esc tanqueu la finestra amb el ratol\u00ed o combinaci\u00f3 de tecles Alt + F4 . (Comproveu-ho, per\u00f2 recordeu afegir pygame.display.flip() per a que pinte la pantalla al bucle).","title":"Processament d'esdeveniments"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#pintant-objectes-a-la-pantalla","text":"Al programa de mostra, hem dibuixat a la pantalla mitjan\u00e7ant dos m\u00e8todes: screen.fill() per omplir el fons pygame.draw.circle() per dibuixar un cercle Ara veurem una tercera manera de dibuixar a la pantalla: utilitzar una superf\u00edcie Surface . Una superf\u00edcie \u00e9s un objecte rectangular sobre el qual podem dibuixar, com un full de paper en blanc. La pantalla \u00e9s una superf\u00edcie i podeu crear els vostres propis objectes de superf\u00edcie separats de la pantalla. Vegem com funciona: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with white screen . fill (( 255 , 255 , 255 )) # Create a surface and pass in a tuple containing its length and width surf = pygame . Surface (( 50 , 50 )) # Give the surface a color to separate it from the background surf . fill (( 0 , 0 , 0 )) rect = surf . get_rect () A la primera l\u00ednia la pantalla s'omple de blanc. Despr\u00e9s es crea una nova superf\u00edcie de 50 p\u00edxels d'ample, 50 p\u00edxels d'al\u00e7ada i s'assigna a surf . Ara surf \u00e9s una superf\u00edcie igual que la pantalla principal i l'omplim de negre. Accedim al seu rectangle subjacentmitjan\u00e7ant get_rect() per poder-ho utilitzar posteriorment.","title":"Pintant objectes a la pantalla"},{"location":"unitats/python/pr%C3%A0ctiques/2%20-%20Disseny/#us-de-blit-i-flip","text":"El fet de crear una nova superf\u00edcie no \u00e9s suficient per veure-la a la pantalla. Per fer-ho, cal que col\u00b7loqueu la superf\u00edcie sobre una altra superf\u00edcie. El terme blit significa Block Transfer (Transfer\u00e8ncia de blocs) i .blit() \u00e9s la forma de copiar el contingut d\u2019una superf\u00edcie a una altra. Nom\u00e9s podeu copiar el contingut entre superf\u00edcies, per\u00f2 ja haviem dit que screen \u00e9s una superf\u00edcie. Vegem com dibuixem surf a la pantalla: Python 1 2 3 # This line says \"Draw surf onto the screen at the center\" screen . blit ( surf , ( SCREEN_WIDTH / 2 , SCREEN_HEIGHT / 2 )) pygame . display . flip () La funci\u00f3 blit pren dos arguments: 1. La superf\u00edcie a pintar 2. Les coordenades del v\u00e8rtex top-left Per tant si ho volem pintar exactament al centre de la pantalla hauriem de restar la seua amplada i altura respectivament: Python 1 2 3 4 5 6 7 8 9 # Put the center of surf at the center of the display surf_center = ( ( SCREEN_WIDTH - surf . get_width ()) / 2 , ( SCREEN_HEIGHT - surf . get_height ()) / 2 ) # Draw surf at the new coordinates screen . blit ( surf , surf_center ) pygame . display . flip () Recordeu fer la crida a la funci\u00f3 flip per a repintar el joc.","title":"\u00das de .blit () i .flip ()"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/","text":"Sprites Al disseny del joc, el jugador comen\u00e7a per l\u2019esquerra i els obstacles entren per la dreta. Podeu representar tots els obstacles amb objectes de la superf\u00edcie per fer tot el dibuix m\u00e9s f\u00e0cil, per\u00f2 com sabeu on dibuixar-los? Com se sap si un obstacle ha xocat amb el jugador? Qu\u00e8 passa quan l'obstacle ix de la pantalla? Qu\u00e8 passa si voleu dibuixar imatges de fons que tamb\u00e9 es moguin? Qu\u00e8 passa si voleu que les vostres imatges siguen animades? Podeu gestionar totes aquestes situacions i molt m\u00e9s amb els sprites . En termes de programaci\u00f3, un sprite \u00e9s una representaci\u00f3 2D d'alguna cosa a la pantalla. Essencialment, \u00e9s una imatge. pygame proporciona una classe Sprite, que est\u00e0 dissenyada per contenir una o diverses representacions gr\u00e0fiques de qualsevol objecte de joc que vulgueu mostrar a la pantalla. Per utilitzar-lo, creeu una nova classe que herede d'Sprite. Aix\u00f2 us permet utilitzar els seus m\u00e8todes heredats. Jugadors A continuaci\u00f3 s\u2019explica com s\u2019utilitzen els objectes Sprite amb el joc actual per definir el jugador. Python 1 2 3 4 5 6 7 8 # Define a Player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () Primer definiu Player ampliant pygame.sprite.Sprite. Despr\u00e9s .__ init __() utilitza .super() per cridar al constructor de la classe pare. A continuaci\u00f3, definim i inicialitzem .surf per mantindre la imatge que voleu mostrar, que actualment \u00e9s un quadre blanc. Tamb\u00e9 definim i inicialitzem .rect, que s'utilitzar\u00e0 m\u00e9s endavant. Per utilitzar aquesta nova classe, heu de crear un objecte nou i canviar tamb\u00e9 el codi de dibuix. Amplieu el bloc de codi seg\u00fcent per veure-ho tot junt: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT , ) # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Define a player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () # Initialize pygame pygame . init () # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Instantiate player. Right now, this is just a rectangle. player = Player () # Variable to keep the main loop running running = True # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw the player on the screen #screen.blit(player.surf, (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)) screen . blit ( player . surf , player . rect ) # Update the display pygame . display . flip () Entrada d\u2019usuari Fins ara, hem apr\u00e8s a configurar Pygame i dibuixar objectes a la pantalla. Ara comen\u00e7a la diversi\u00f3. Fareu que el joc es puga controlar mitjan\u00e7ant el teclat. Abans, haviem vist que pygame.event.get() retorna la llista dels esdeveniments de la cua, que analitzem per trobar els seus tipus. B\u00e9, aquesta no \u00e9s l\u2019\u00fanica manera de llegir les tecles. pygame tamb\u00e9 proporciona pygame.event.get_pressed() , que retorna un diccionari que cont\u00e9 tots els esdeveniments KEYDOWN actuals a la cua. Posar-ho al bucle del joc despr\u00e9s del bucle de gesti\u00f3 d'esdeveniments torna un diccionari que cont\u00e9 les tecles apretades al comen\u00e7ament de cada fotograma. A continuaci\u00f3, escrivim un m\u00e8tode a Player per analitzar aquest diccionari. Aix\u00f2 definir\u00e0 el comportament del sprite a partir de les tecles que es premen. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) K_UP, K_DOWN, K_LEFT i K_RIGHT corresponen a les tecles de les fletxes del teclat. Utilitzarem .move_ip() , que significa moure des del punt actual, i reb per par\u00e0metre el n\u00famero de pixels a moure's en horitzontal i en vertical com si es tractara d'un eix de coordenades. A continuaci\u00f3, cridem a .update() cada fotograma per moure el sprite del jugador en resposta a les pulsacions de tecles. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Get all the keys currently pressed pressed_keys = pygame . key . get_pressed () # Update the player sprite based on user keypresses player . update ( pressed_keys ) # Fill the screen with black screen . fill (( 0 , 0 , 0 )) Amb aix\u00f2, ja veiem que el Player es mou tant en horitzontal com en vertical. \u00c9s possible que noteu dos problemes: El rectangle del jugador es mou molt r\u00e0pid. Ho solucionarem m\u00e9s endavant. El rectangle del jugador pot ixir-se'n de la pantalla. Solucionem-ho ara. Per mantenir el jugador a la pantalla, cal afegir la l\u00f2gica per detectar les colisions entre el jugador i els l\u00edmits de la pantalla. Per fer-ho, comprovem si les coordenades del rectangle s\u2019han despla\u00e7at m\u00e9s enll\u00e0 del l\u00edmit de la pantalla. Si \u00e9s aix\u00ed, indiquem al programa que el torne a la vora, quedant la funci\u00f3 update com a continuaci\u00f3 s'indica: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) # Keep player on the screen if self . rect . left < 0 : self . rect . left = 0 if self . rect . right > SCREEN_WIDTH : self . rect . right = SCREEN_WIDTH if self . rect . top <= 0 : self . rect . top = 0 if self . rect . bottom >= SCREEN_HEIGHT : self . rect . bottom = SCREEN_HEIGHT Ac\u00ed, en lloc d\u2019utilitzar .move() , nom\u00e9s heu de canviar les coordenades corresponents de .top, .bottom, .left o .right directament. Proveu-ho i veureu que el rectangle del reproductor ja no pot ixir-se'n de la pantalla. Enemics Qu\u00e8 \u00e9s un joc sense enemics? Utilitzarem les mateixes t\u00e8cniques que ja hem apr\u00e8s per crear una classe enemiga b\u00e0sica i, a continuaci\u00f3, crearem moltes inst\u00e0ncies d'aquesta per a que el jugador intente evitar-les. Primer, importeu la llibreria random . A continuaci\u00f3, creeu una nova classe de sprite anomenada Enemy , seguint el mateix patr\u00f3 que utilitzarem per a Player : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Import random for random numbers import random # Define the enemy object by extending pygame.sprite.Sprite # The surface you draw on the screen is now an attribute of 'enemy' class Enemy ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Enemy , self ) . __init__ () self . surf = pygame . Surface (( 20 , 10 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect ( center = ( random . randint ( SCREEN_WIDTH + 20 , SCREEN_WIDTH + 100 ), random . randint ( 0 , SCREEN_HEIGHT ), ) ) self . speed = random . randint ( 5 , 20 ) # Move the sprite based on speed # Remove the sprite when it passes the left edge of the screen def update ( self ): self . rect . move_ip ( - self . speed , 0 ) if self . rect . right < 0 : self . kill () Hi ha quatre difer\u00e8ncies notables entre Enemic i Jugador: Quan creem un enemic ho fem a una ubicaci\u00f3 aleat\u00f2ria al llarg de la vora dreta de la pantalla. Es troba en una posici\u00f3 entre 20 i 100 p\u00edxels de dist\u00e0ncia de la vora dreta i en algun lloc entre la vora superior i la inferior. De forma que al principi no ser\u00e0 visible i anir\u00e0 apareixent per la vora dreta de la pantalla. Definim una velocitat speed com un n\u00famero aleatori entre 5 i 20. Aix\u00f2 especifica la velocitat amb qu\u00e8 aquest enemic es mou cap al jugador. .update() no necessita arguments, ja que els enemics es mouen autom\u00e0ticament cap a l'esquerra a la velocitat aleat\u00f2ria definida quan es va crear i que ja no canvia. Comprovem si l'enemic s'ha mogut fora de la pantalla al sobrepassar la vora esquerra. Per assegurar-nos que l\u2019enemic estiga completament fora de la pantalla i que no desaparega mentre encara siga visible, comprovem que el costat dret de . rect haja sobrepassat el costat esquerre de la pantalla. Una vegada que l'enemic es troba fora de pantalla, cridem a .kill() per evitar anar consumint m\u00e9s recursos cada vegada. Qu\u00e8 fa .kill() ? Per saber-ho, estudiem els Sprite Groups . Sprite Groups Una altra classe s\u00faper \u00fatil que proporciona Pygame s\u00f3n els Sprite Groups . Es tracta d'un objecte que cont\u00e9 un grup d'objectes Sprite. Aleshores, per qu\u00e8 utilitzar-lo? No podem fer el seguiment dels nostres objectes Sprite en una llista? B\u00e9, podem, per\u00f2 l\u2019avantatge d\u2019utilitzar un grup radica en els m\u00e8todes que exposa. Aquests m\u00e8todes ajuden a detectar si algun enemic ha xocat amb el jugador, cosa que facilita les actualitzacions. Vegem com crear Sprite Group . Creem dos objectes de grup diferents: El primer grup tindr\u00e0 tots els Sprite del joc. El segon grup tindr\u00e0 nom\u00e9s els objectes enemics. A continuaci\u00f3, es mostra el codi: Python 1 2 3 4 5 6 7 8 9 10 11 12 # Create the 'player' player = Player () # Create groups to hold enemy sprites and all sprites # - enemies is used for collision detection and position updates # - all_sprites is used for rendering enemies = pygame . sprite . Group () all_sprites = pygame . sprite . Group () all_sprites . add ( player ) # Variable to keep the main loop running running = True Quan cridem el m\u00e8tode .kill() , el Sprite s\u2019elimina de tots els grups als quals pertany. Aix\u00f2 tamb\u00e9 elimina les refer\u00e8ncies al Sprite, cosa que permet al garbage collector de Python recuperar la mem\u00f2ria quan siga necessari. Ara que teniu un grup all_sprites, podeu canviar la manera com es dibuixen els objectes. En lloc de cridar a .blit() nom\u00e9s amb Player, podem repintar tot sobre all_sprites: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Flip everything to the display pygame . display . flip () Ara, qualsevol objecte d' all_sprites es redibuixar\u00e0 a tots els fotogrames, ja sigui un enemic o un jugador. Nom\u00e9s hi ha un problema ... No tenim cap enemic. Podriem crear un munt d\u2019enemics al principi del joc, per\u00f2 el joc es tornaria complicad\u00edssim a l'apareixer tots junts. En el seu lloc, explorem com mantenir un subministrament constant d\u2019enemics que arriben a mesura que avance el joc. Esdeveniments personalitzats El disseny demana que apareguen enemics a intervals regulars. Aix\u00f2 significa que, a intervals establerts, hem de fer dues coses: Crea un enemic nou. Afegiu-lo a all_sprites i a enemics. (Sprite Groups) Ja teniu codi que gestiona esdeveniments aleatoris. El bucle d'esdeveniments est\u00e0 dissenyat per buscar esdeveniments aleatoris que es produeixen a cada fotograma i tractar-los adequadament. Per sort, pygame no us limita a utilitzar nom\u00e9s els tipus d\u2019esdeveniments que t\u00e9 predefinits. Podeu definir els vostres propis esdeveniments per gestionar-los segons convinga. Vegem com es crea un esdeveniment personalitzat que es genera cada pocs segons. Podeu crear un esdeveniment personalitzat com es mostra a continuaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Create a custom event for adding a new enemy ADDENEMY = pygame . USEREVENT + 1 pygame . time . set_timer ( ADDENEMY , 250 ) # Instantiate player. Right now, this is just a rectangle. player = Player () pygame defineix els esdeveniments internament com a enters, de manera que cal definir un nou esdeveniment amb un enter \u00fanic. L'\u00faltim esdeveniment reservat a Pygame es diu USEREVENT , de manera que definir ADDENEMY = pygame.USEREVENT + 1 garanteix que siga \u00fanic. A continuaci\u00f3, heu d'insertar aquest nou esdeveniment a la cua d'esdeveniments a intervals regulars durant tot el joc. Necessitem d'alguna forma gestionar el temps, per aix\u00f2 utilitzarem el m\u00f2dul de temps. Disparem el nou esdeveniment ADDENEMY cada 250 mil\u00b7lisegons, o quatre vegades per segon. Per aix\u00f2 farem una crida a .set_timer() fora del bucle del joc, ja que nom\u00e9s necessitem un temporitzador, per\u00f2 es disparar\u00e0 durant tot el joc cada 250 milisegons. Afegim el codi per gestionar el nostre nou esdeveniment. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False # Add a new enemy? elif event . type == ADDENEMY : # Create the new enemy and add it to sprite groups new_enemy = Enemy () enemies . add ( new_enemy ) all_sprites . add ( new_enemy ) # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () player . update ( pressed_keys ) # Update enemy position enemies . update () Sempre que el gestor d'esdeveniments veu el nou esdeveniment ADDENEMY, crea un enemic i l'afegeix a enemies i a all_sprites . Com que Enemy est\u00e0 en all_sprites , es dibuixar\u00e0 a cada fotograma. Tamb\u00e9 heu de cridar a enemies.update() , que actualitza totes les posicions dels enemics. Detecci\u00f3 de col\u00b7lisions El disseny del joc demana que finalitze el joc sempre que un enemic xoque amb el jugador. La comprovaci\u00f3 de col\u00b7lisions \u00e9s una t\u00e8cnica b\u00e0sica de programaci\u00f3 de jocs i, en general, requereix alguns c\u00e0lculs matem\u00e0tics per determinar si dos sprites se superposaran. Aqu\u00ed \u00e9s on resulta \u00fatil un framework com Pygame. Escriure un codi de detecci\u00f3 de col\u00b7lisions \u00e9s tedi\u00f3s, per\u00f2 Pygame t\u00e9 MOLTS m\u00e8todes de detecci\u00f3 de col\u00b7lisions disponibles per utilitzar-los. Per a aquest tutorial, utilitzeu un m\u00e8tode anomenat .spritecollideany() , que detecta qualsevol col\u00b7lisi\u00f3 entre un sprite i els sprites d'un grup. Accepta un Sprite i un Grup com a par\u00e0metres. Comprova les superposicions entre tots els .rect del grup i el .rect de l'sprite. Si \u00e9s aix\u00ed, torna True, \u00e9s a dir si detecta col\u00b7lisi\u00f3. En cas contrari, torna False. Aix\u00f2 s'ajusta perfectament a aquest joc, ja que hem de comprovar si un sol jugador xoca amb un grup d'enemics. Vegem el codi: Python 1 2 3 4 5 6 7 8 9 # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Check if any enemies have collided with the player if pygame . sprite . spritecollideany ( player , enemies ): # If so, then remove the player and stop the loop player . kill () running = False Es comprova si el jugador ha xocat amb algun enemic. Si \u00e9s aix\u00ed, es crida a player.kill() per eliminar-lo de tots els grups als quals pertany. Com que els \u00fanics objectes que es representen es troben en all_sprites , el jugador ja no es renderitzar\u00e0. Una vegada que el jugador haja perdur, tamb\u00e9 haurem d'eixir del joc, de manera que configureu running = False per ixir del bucle del joc. Velocitat del joc En provar el joc, potser vos haureu adonat que els enemics es mouen massa r\u00e0pid. Si no, tranquils, ja que el joc s'executar\u00e0 a diferents velocitats segons el hardware subjacent, el sistema operatiu, etc. La ra\u00f3 d'aix\u00f2 \u00e9s que el bucle del joc processa els fotogrames tan r\u00e0pidament com el processador i l'entorn ho permeten. Com que tots els sprites es mouen una vegada per fotograma, es poden moure centenars de vegades cada segon. El nombre de fotogrames que es manegen cada segon s\u2019anomena velocitat de fotogrames ( frame rate ), un terme molt utilitzat pels gamers. Aconseguir-ne un adequat \u00e9s la difer\u00e8ncia entre un joc jugable i un altre que no ho \u00e9s. Normalment, volem una freq\u00fc\u00e8ncia de fotogrames el m\u00e9s alta possible, per poder apreciar el major nombre de detalls, per\u00f2, per a aquest joc, cal reduir-lo un poc perqu\u00e8 el joc es puga jugar. Afortunadament, el m\u00f2dul de temps de Python cont\u00e9 un rellotge dissenyat exactament per a aquest prop\u00f2sit. L\u2019\u00fas del rellotge per establir una velocitat de fotogrames reprodu\u00efble requereix nom\u00e9s dues l\u00ednies de codi. El primer crea un rellotge nou abans que comence el bucle del joc. Despr\u00e9s utilitzem la funci\u00f3 .tick() per informar a pygame que el programa ha arribat al final del fotograma. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Setup the clock for a decent framerate clock = pygame . time . Clock () ... # Our main loop while running : ... # Flip everything to the display pygame . display . flip () # Ensure program maintains a rate of 30 frames per second clock . tick ( 30 ) L'argument passat a .tick() estableix la velocitat de fotogrames desitjada. Per fer-ho, es calcula el nombre de mil\u00b7lisegons que ha de tardar cada fotograma, en funci\u00f3 de la velocitat de fotogrames desitjada. A continuaci\u00f3, compara aquest nombre amb el nombre de mil\u00b7lisegons que han passat des de la darrera vegada que es va cridar .tick() . Si no ha passat prou temps, retarda el processament per assegurar-se que mai no supera la velocitat de fotogrames especificada. Si es passa una freq\u00fc\u00e8ncia de fotogrames m\u00e9s xicoteta, transcorrer\u00e0 m\u00e9s temps entre fotogrames, mentre que una freq\u00fc\u00e8ncia de fotogrames m\u00e9s gran proporcionar\u00e0 un joc m\u00e9s suau (i m\u00e9s r\u00e0pid). En aquest moment, tenim un joc totalment funcional i jugable.","title":"Sprites"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#sprites","text":"Al disseny del joc, el jugador comen\u00e7a per l\u2019esquerra i els obstacles entren per la dreta. Podeu representar tots els obstacles amb objectes de la superf\u00edcie per fer tot el dibuix m\u00e9s f\u00e0cil, per\u00f2 com sabeu on dibuixar-los? Com se sap si un obstacle ha xocat amb el jugador? Qu\u00e8 passa quan l'obstacle ix de la pantalla? Qu\u00e8 passa si voleu dibuixar imatges de fons que tamb\u00e9 es moguin? Qu\u00e8 passa si voleu que les vostres imatges siguen animades? Podeu gestionar totes aquestes situacions i molt m\u00e9s amb els sprites . En termes de programaci\u00f3, un sprite \u00e9s una representaci\u00f3 2D d'alguna cosa a la pantalla. Essencialment, \u00e9s una imatge. pygame proporciona una classe Sprite, que est\u00e0 dissenyada per contenir una o diverses representacions gr\u00e0fiques de qualsevol objecte de joc que vulgueu mostrar a la pantalla. Per utilitzar-lo, creeu una nova classe que herede d'Sprite. Aix\u00f2 us permet utilitzar els seus m\u00e8todes heredats.","title":"Sprites"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#jugadors","text":"A continuaci\u00f3 s\u2019explica com s\u2019utilitzen els objectes Sprite amb el joc actual per definir el jugador. Python 1 2 3 4 5 6 7 8 # Define a Player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () Primer definiu Player ampliant pygame.sprite.Sprite. Despr\u00e9s .__ init __() utilitza .super() per cridar al constructor de la classe pare. A continuaci\u00f3, definim i inicialitzem .surf per mantindre la imatge que voleu mostrar, que actualment \u00e9s un quadre blanc. Tamb\u00e9 definim i inicialitzem .rect, que s'utilitzar\u00e0 m\u00e9s endavant. Per utilitzar aquesta nova classe, heu de crear un objecte nou i canviar tamb\u00e9 el codi de dibuix. Amplieu el bloc de codi seg\u00fcent per veure-ho tot junt: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT , ) # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Define a player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () # Initialize pygame pygame . init () # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Instantiate player. Right now, this is just a rectangle. player = Player () # Variable to keep the main loop running running = True # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw the player on the screen #screen.blit(player.surf, (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)) screen . blit ( player . surf , player . rect ) # Update the display pygame . display . flip ()","title":"Jugadors"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#entrada-dusuari","text":"Fins ara, hem apr\u00e8s a configurar Pygame i dibuixar objectes a la pantalla. Ara comen\u00e7a la diversi\u00f3. Fareu que el joc es puga controlar mitjan\u00e7ant el teclat. Abans, haviem vist que pygame.event.get() retorna la llista dels esdeveniments de la cua, que analitzem per trobar els seus tipus. B\u00e9, aquesta no \u00e9s l\u2019\u00fanica manera de llegir les tecles. pygame tamb\u00e9 proporciona pygame.event.get_pressed() , que retorna un diccionari que cont\u00e9 tots els esdeveniments KEYDOWN actuals a la cua. Posar-ho al bucle del joc despr\u00e9s del bucle de gesti\u00f3 d'esdeveniments torna un diccionari que cont\u00e9 les tecles apretades al comen\u00e7ament de cada fotograma. A continuaci\u00f3, escrivim un m\u00e8tode a Player per analitzar aquest diccionari. Aix\u00f2 definir\u00e0 el comportament del sprite a partir de les tecles que es premen. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) K_UP, K_DOWN, K_LEFT i K_RIGHT corresponen a les tecles de les fletxes del teclat. Utilitzarem .move_ip() , que significa moure des del punt actual, i reb per par\u00e0metre el n\u00famero de pixels a moure's en horitzontal i en vertical com si es tractara d'un eix de coordenades. A continuaci\u00f3, cridem a .update() cada fotograma per moure el sprite del jugador en resposta a les pulsacions de tecles. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Get all the keys currently pressed pressed_keys = pygame . key . get_pressed () # Update the player sprite based on user keypresses player . update ( pressed_keys ) # Fill the screen with black screen . fill (( 0 , 0 , 0 )) Amb aix\u00f2, ja veiem que el Player es mou tant en horitzontal com en vertical. \u00c9s possible que noteu dos problemes: El rectangle del jugador es mou molt r\u00e0pid. Ho solucionarem m\u00e9s endavant. El rectangle del jugador pot ixir-se'n de la pantalla. Solucionem-ho ara. Per mantenir el jugador a la pantalla, cal afegir la l\u00f2gica per detectar les colisions entre el jugador i els l\u00edmits de la pantalla. Per fer-ho, comprovem si les coordenades del rectangle s\u2019han despla\u00e7at m\u00e9s enll\u00e0 del l\u00edmit de la pantalla. Si \u00e9s aix\u00ed, indiquem al programa que el torne a la vora, quedant la funci\u00f3 update com a continuaci\u00f3 s'indica: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) # Keep player on the screen if self . rect . left < 0 : self . rect . left = 0 if self . rect . right > SCREEN_WIDTH : self . rect . right = SCREEN_WIDTH if self . rect . top <= 0 : self . rect . top = 0 if self . rect . bottom >= SCREEN_HEIGHT : self . rect . bottom = SCREEN_HEIGHT Ac\u00ed, en lloc d\u2019utilitzar .move() , nom\u00e9s heu de canviar les coordenades corresponents de .top, .bottom, .left o .right directament. Proveu-ho i veureu que el rectangle del reproductor ja no pot ixir-se'n de la pantalla.","title":"Entrada d\u2019usuari"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#enemics","text":"Qu\u00e8 \u00e9s un joc sense enemics? Utilitzarem les mateixes t\u00e8cniques que ja hem apr\u00e8s per crear una classe enemiga b\u00e0sica i, a continuaci\u00f3, crearem moltes inst\u00e0ncies d'aquesta per a que el jugador intente evitar-les. Primer, importeu la llibreria random . A continuaci\u00f3, creeu una nova classe de sprite anomenada Enemy , seguint el mateix patr\u00f3 que utilitzarem per a Player : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Import random for random numbers import random # Define the enemy object by extending pygame.sprite.Sprite # The surface you draw on the screen is now an attribute of 'enemy' class Enemy ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Enemy , self ) . __init__ () self . surf = pygame . Surface (( 20 , 10 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect ( center = ( random . randint ( SCREEN_WIDTH + 20 , SCREEN_WIDTH + 100 ), random . randint ( 0 , SCREEN_HEIGHT ), ) ) self . speed = random . randint ( 5 , 20 ) # Move the sprite based on speed # Remove the sprite when it passes the left edge of the screen def update ( self ): self . rect . move_ip ( - self . speed , 0 ) if self . rect . right < 0 : self . kill () Hi ha quatre difer\u00e8ncies notables entre Enemic i Jugador: Quan creem un enemic ho fem a una ubicaci\u00f3 aleat\u00f2ria al llarg de la vora dreta de la pantalla. Es troba en una posici\u00f3 entre 20 i 100 p\u00edxels de dist\u00e0ncia de la vora dreta i en algun lloc entre la vora superior i la inferior. De forma que al principi no ser\u00e0 visible i anir\u00e0 apareixent per la vora dreta de la pantalla. Definim una velocitat speed com un n\u00famero aleatori entre 5 i 20. Aix\u00f2 especifica la velocitat amb qu\u00e8 aquest enemic es mou cap al jugador. .update() no necessita arguments, ja que els enemics es mouen autom\u00e0ticament cap a l'esquerra a la velocitat aleat\u00f2ria definida quan es va crear i que ja no canvia. Comprovem si l'enemic s'ha mogut fora de la pantalla al sobrepassar la vora esquerra. Per assegurar-nos que l\u2019enemic estiga completament fora de la pantalla i que no desaparega mentre encara siga visible, comprovem que el costat dret de . rect haja sobrepassat el costat esquerre de la pantalla. Una vegada que l'enemic es troba fora de pantalla, cridem a .kill() per evitar anar consumint m\u00e9s recursos cada vegada. Qu\u00e8 fa .kill() ? Per saber-ho, estudiem els Sprite Groups .","title":"Enemics"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#sprite-groups","text":"Una altra classe s\u00faper \u00fatil que proporciona Pygame s\u00f3n els Sprite Groups . Es tracta d'un objecte que cont\u00e9 un grup d'objectes Sprite. Aleshores, per qu\u00e8 utilitzar-lo? No podem fer el seguiment dels nostres objectes Sprite en una llista? B\u00e9, podem, per\u00f2 l\u2019avantatge d\u2019utilitzar un grup radica en els m\u00e8todes que exposa. Aquests m\u00e8todes ajuden a detectar si algun enemic ha xocat amb el jugador, cosa que facilita les actualitzacions. Vegem com crear Sprite Group . Creem dos objectes de grup diferents: El primer grup tindr\u00e0 tots els Sprite del joc. El segon grup tindr\u00e0 nom\u00e9s els objectes enemics. A continuaci\u00f3, es mostra el codi: Python 1 2 3 4 5 6 7 8 9 10 11 12 # Create the 'player' player = Player () # Create groups to hold enemy sprites and all sprites # - enemies is used for collision detection and position updates # - all_sprites is used for rendering enemies = pygame . sprite . Group () all_sprites = pygame . sprite . Group () all_sprites . add ( player ) # Variable to keep the main loop running running = True Quan cridem el m\u00e8tode .kill() , el Sprite s\u2019elimina de tots els grups als quals pertany. Aix\u00f2 tamb\u00e9 elimina les refer\u00e8ncies al Sprite, cosa que permet al garbage collector de Python recuperar la mem\u00f2ria quan siga necessari. Ara que teniu un grup all_sprites, podeu canviar la manera com es dibuixen els objectes. En lloc de cridar a .blit() nom\u00e9s amb Player, podem repintar tot sobre all_sprites: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Flip everything to the display pygame . display . flip () Ara, qualsevol objecte d' all_sprites es redibuixar\u00e0 a tots els fotogrames, ja sigui un enemic o un jugador. Nom\u00e9s hi ha un problema ... No tenim cap enemic. Podriem crear un munt d\u2019enemics al principi del joc, per\u00f2 el joc es tornaria complicad\u00edssim a l'apareixer tots junts. En el seu lloc, explorem com mantenir un subministrament constant d\u2019enemics que arriben a mesura que avance el joc.","title":"Sprite Groups"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#esdeveniments-personalitzats","text":"El disseny demana que apareguen enemics a intervals regulars. Aix\u00f2 significa que, a intervals establerts, hem de fer dues coses: Crea un enemic nou. Afegiu-lo a all_sprites i a enemics. (Sprite Groups) Ja teniu codi que gestiona esdeveniments aleatoris. El bucle d'esdeveniments est\u00e0 dissenyat per buscar esdeveniments aleatoris que es produeixen a cada fotograma i tractar-los adequadament. Per sort, pygame no us limita a utilitzar nom\u00e9s els tipus d\u2019esdeveniments que t\u00e9 predefinits. Podeu definir els vostres propis esdeveniments per gestionar-los segons convinga. Vegem com es crea un esdeveniment personalitzat que es genera cada pocs segons. Podeu crear un esdeveniment personalitzat com es mostra a continuaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Create a custom event for adding a new enemy ADDENEMY = pygame . USEREVENT + 1 pygame . time . set_timer ( ADDENEMY , 250 ) # Instantiate player. Right now, this is just a rectangle. player = Player () pygame defineix els esdeveniments internament com a enters, de manera que cal definir un nou esdeveniment amb un enter \u00fanic. L'\u00faltim esdeveniment reservat a Pygame es diu USEREVENT , de manera que definir ADDENEMY = pygame.USEREVENT + 1 garanteix que siga \u00fanic. A continuaci\u00f3, heu d'insertar aquest nou esdeveniment a la cua d'esdeveniments a intervals regulars durant tot el joc. Necessitem d'alguna forma gestionar el temps, per aix\u00f2 utilitzarem el m\u00f2dul de temps. Disparem el nou esdeveniment ADDENEMY cada 250 mil\u00b7lisegons, o quatre vegades per segon. Per aix\u00f2 farem una crida a .set_timer() fora del bucle del joc, ja que nom\u00e9s necessitem un temporitzador, per\u00f2 es disparar\u00e0 durant tot el joc cada 250 milisegons. Afegim el codi per gestionar el nostre nou esdeveniment. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False # Add a new enemy? elif event . type == ADDENEMY : # Create the new enemy and add it to sprite groups new_enemy = Enemy () enemies . add ( new_enemy ) all_sprites . add ( new_enemy ) # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () player . update ( pressed_keys ) # Update enemy position enemies . update () Sempre que el gestor d'esdeveniments veu el nou esdeveniment ADDENEMY, crea un enemic i l'afegeix a enemies i a all_sprites . Com que Enemy est\u00e0 en all_sprites , es dibuixar\u00e0 a cada fotograma. Tamb\u00e9 heu de cridar a enemies.update() , que actualitza totes les posicions dels enemics.","title":"Esdeveniments personalitzats"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#deteccio-de-collisions","text":"El disseny del joc demana que finalitze el joc sempre que un enemic xoque amb el jugador. La comprovaci\u00f3 de col\u00b7lisions \u00e9s una t\u00e8cnica b\u00e0sica de programaci\u00f3 de jocs i, en general, requereix alguns c\u00e0lculs matem\u00e0tics per determinar si dos sprites se superposaran. Aqu\u00ed \u00e9s on resulta \u00fatil un framework com Pygame. Escriure un codi de detecci\u00f3 de col\u00b7lisions \u00e9s tedi\u00f3s, per\u00f2 Pygame t\u00e9 MOLTS m\u00e8todes de detecci\u00f3 de col\u00b7lisions disponibles per utilitzar-los. Per a aquest tutorial, utilitzeu un m\u00e8tode anomenat .spritecollideany() , que detecta qualsevol col\u00b7lisi\u00f3 entre un sprite i els sprites d'un grup. Accepta un Sprite i un Grup com a par\u00e0metres. Comprova les superposicions entre tots els .rect del grup i el .rect de l'sprite. Si \u00e9s aix\u00ed, torna True, \u00e9s a dir si detecta col\u00b7lisi\u00f3. En cas contrari, torna False. Aix\u00f2 s'ajusta perfectament a aquest joc, ja que hem de comprovar si un sol jugador xoca amb un grup d'enemics. Vegem el codi: Python 1 2 3 4 5 6 7 8 9 # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Check if any enemies have collided with the player if pygame . sprite . spritecollideany ( player , enemies ): # If so, then remove the player and stop the loop player . kill () running = False Es comprova si el jugador ha xocat amb algun enemic. Si \u00e9s aix\u00ed, es crida a player.kill() per eliminar-lo de tots els grups als quals pertany. Com que els \u00fanics objectes que es representen es troben en all_sprites , el jugador ja no es renderitzar\u00e0. Una vegada que el jugador haja perdur, tamb\u00e9 haurem d'eixir del joc, de manera que configureu running = False per ixir del bucle del joc.","title":"Detecci\u00f3 de col\u00b7lisions"},{"location":"unitats/python/pr%C3%A0ctiques/3%20-%20Sprites/#velocitat-del-joc","text":"En provar el joc, potser vos haureu adonat que els enemics es mouen massa r\u00e0pid. Si no, tranquils, ja que el joc s'executar\u00e0 a diferents velocitats segons el hardware subjacent, el sistema operatiu, etc. La ra\u00f3 d'aix\u00f2 \u00e9s que el bucle del joc processa els fotogrames tan r\u00e0pidament com el processador i l'entorn ho permeten. Com que tots els sprites es mouen una vegada per fotograma, es poden moure centenars de vegades cada segon. El nombre de fotogrames que es manegen cada segon s\u2019anomena velocitat de fotogrames ( frame rate ), un terme molt utilitzat pels gamers. Aconseguir-ne un adequat \u00e9s la difer\u00e8ncia entre un joc jugable i un altre que no ho \u00e9s. Normalment, volem una freq\u00fc\u00e8ncia de fotogrames el m\u00e9s alta possible, per poder apreciar el major nombre de detalls, per\u00f2, per a aquest joc, cal reduir-lo un poc perqu\u00e8 el joc es puga jugar. Afortunadament, el m\u00f2dul de temps de Python cont\u00e9 un rellotge dissenyat exactament per a aquest prop\u00f2sit. L\u2019\u00fas del rellotge per establir una velocitat de fotogrames reprodu\u00efble requereix nom\u00e9s dues l\u00ednies de codi. El primer crea un rellotge nou abans que comence el bucle del joc. Despr\u00e9s utilitzem la funci\u00f3 .tick() per informar a pygame que el programa ha arribat al final del fotograma. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Setup the clock for a decent framerate clock = pygame . time . Clock () ... # Our main loop while running : ... # Flip everything to the display pygame . display . flip () # Ensure program maintains a rate of 30 frames per second clock . tick ( 30 ) L'argument passat a .tick() estableix la velocitat de fotogrames desitjada. Per fer-ho, es calcula el nombre de mil\u00b7lisegons que ha de tardar cada fotograma, en funci\u00f3 de la velocitat de fotogrames desitjada. A continuaci\u00f3, compara aquest nombre amb el nombre de mil\u00b7lisegons que han passat des de la darrera vegada que es va cridar .tick() . Si no ha passat prou temps, retarda el processament per assegurar-se que mai no supera la velocitat de fotogrames especificada. Si es passa una freq\u00fc\u00e8ncia de fotogrames m\u00e9s xicoteta, transcorrer\u00e0 m\u00e9s temps entre fotogrames, mentre que una freq\u00fc\u00e8ncia de fotogrames m\u00e9s gran proporcionar\u00e0 un joc m\u00e9s suau (i m\u00e9s r\u00e0pid). En aquest moment, tenim un joc totalment funcional i jugable.","title":"Velocitat del joc"},{"location":"unitats/python/pr%C3%A0ctiques/4%20-%20Imatges/","text":"Imatges dels Sprites Molt b\u00e9, tens un joc, per\u00f2 siguem sincers ... L'aspecte no \u00e9s massa amigable. El jugador i els enemics s\u00f3n nom\u00e9s blocs blancs sobre fons negre. Va ser una revoluci\u00f3 quan va apar\u00e8ixer el Pong el 1972, per\u00f2 ha quedat antiquat. Anem a substituir aquests rectangles blancs per unes imatges que faran el joc m\u00e9s amigable. Anem a carregar una imatge d'un avi\u00f3 per al jugador i alguns m\u00edssils per als enemics, encara que podeu utilitzar altres per personalitzar el vostre joc. Alteraci\u00f3 dels constructors d'objectes Abans d\u2019utilitzar imatges per representar el jugador i els sprites enemics, hem de fer alguns canvis als seus constructors. El codi seg\u00fcent substitueix el codi utilitzat anteriorment. Python 1 2 3 4 5 6 class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . image . load ( \"resources/jet.png\" ) . convert () self . surf . set_colorkey (( 255 , 255 , 255 ), RLEACCEL ) self . rect = self . surf . get_rect () Amb pygame.image.load() carreguem una imatge del disc. Li passem com a argument el path a l'arxiu. Retorna una superf\u00edcie i la crida .convert() optimitza la superf\u00edcie, fent que les futures crides al m\u00e8tode .blit() siguen m\u00e9s r\u00e0pides. Amb .set_colorkey() indiquem quin color es far\u00e0 transparent. En aquest cas, triem el blanc, perqu\u00e8 \u00e9s el color de fons de la imatge. La constant RLEACCEL \u00e9s un par\u00e0metre opcional que ajuda a renderitzar pygame m\u00e9s r\u00e0pidament en pantalles no accelerades. Per poder utilitzar esta constant, necessitem importar-la a la declaraci\u00f3 d\u2019importaci\u00f3 de pygame.locals del principi del codi. No hem de canviar res m\u00e9s, la imatge continua sent una superf\u00edcie, tret que ara hi ha una imatge pintada. Farem el mateix al constructor d'enemic, esta vegada carregant la imatge resources/missile.png . Afegir imatges de fons Afegirem ara uns n\u00favols com a imatges de fons, utilitzant els mateixos passos que per a Player i Enemy: Creem la classe Cloud. Afegim la imatge d\u2019un n\u00favol. Creem un m\u00e8tode .update() que mou el n\u00favol cap a la part esquerra de la pantalla 5 p\u00edxels en cada fotograma. Creem un gestor i un esdeveniment personalitzats per crear objectes de n\u00favol nous a un interval de temps definit de 1000ms. Afegim els objectes de n\u00favols creats a un grup nou anomenat n\u00favols. Actualitzem i dibuixem els n\u00favols al bucle principal del joc. Tingueu en compte que cada n\u00favol i enemic nous s\u2019afegeixen a all_sprites , mentre que els n\u00favols ho fan al grup clouds i els enemics a enemies . Perqu\u00e8? El renderitzat (repintat) es fa amb all_sprites. Les actualitzacions de posici\u00f3 es fan a n\u00favols i enemics. La detecci\u00f3 de col\u00b7lisions es fa entre el jugador i enemics, per\u00f2 no amb n\u00favols, ja que un avi\u00f3 pot atrevessar n\u00favols sense problemes. Per \u00faltim canvieu el color de fons del negre a (135, 206, 250).","title":"Imatges"},{"location":"unitats/python/pr%C3%A0ctiques/4%20-%20Imatges/#imatges-dels-sprites","text":"Molt b\u00e9, tens un joc, per\u00f2 siguem sincers ... L'aspecte no \u00e9s massa amigable. El jugador i els enemics s\u00f3n nom\u00e9s blocs blancs sobre fons negre. Va ser una revoluci\u00f3 quan va apar\u00e8ixer el Pong el 1972, per\u00f2 ha quedat antiquat. Anem a substituir aquests rectangles blancs per unes imatges que faran el joc m\u00e9s amigable. Anem a carregar una imatge d'un avi\u00f3 per al jugador i alguns m\u00edssils per als enemics, encara que podeu utilitzar altres per personalitzar el vostre joc.","title":"Imatges dels Sprites"},{"location":"unitats/python/pr%C3%A0ctiques/4%20-%20Imatges/#alteracio-dels-constructors-dobjectes","text":"Abans d\u2019utilitzar imatges per representar el jugador i els sprites enemics, hem de fer alguns canvis als seus constructors. El codi seg\u00fcent substitueix el codi utilitzat anteriorment. Python 1 2 3 4 5 6 class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . image . load ( \"resources/jet.png\" ) . convert () self . surf . set_colorkey (( 255 , 255 , 255 ), RLEACCEL ) self . rect = self . surf . get_rect () Amb pygame.image.load() carreguem una imatge del disc. Li passem com a argument el path a l'arxiu. Retorna una superf\u00edcie i la crida .convert() optimitza la superf\u00edcie, fent que les futures crides al m\u00e8tode .blit() siguen m\u00e9s r\u00e0pides. Amb .set_colorkey() indiquem quin color es far\u00e0 transparent. En aquest cas, triem el blanc, perqu\u00e8 \u00e9s el color de fons de la imatge. La constant RLEACCEL \u00e9s un par\u00e0metre opcional que ajuda a renderitzar pygame m\u00e9s r\u00e0pidament en pantalles no accelerades. Per poder utilitzar esta constant, necessitem importar-la a la declaraci\u00f3 d\u2019importaci\u00f3 de pygame.locals del principi del codi. No hem de canviar res m\u00e9s, la imatge continua sent una superf\u00edcie, tret que ara hi ha una imatge pintada. Farem el mateix al constructor d'enemic, esta vegada carregant la imatge resources/missile.png .","title":"Alteraci\u00f3 dels constructors d'objectes"},{"location":"unitats/python/pr%C3%A0ctiques/4%20-%20Imatges/#afegir-imatges-de-fons","text":"Afegirem ara uns n\u00favols com a imatges de fons, utilitzant els mateixos passos que per a Player i Enemy: Creem la classe Cloud. Afegim la imatge d\u2019un n\u00favol. Creem un m\u00e8tode .update() que mou el n\u00favol cap a la part esquerra de la pantalla 5 p\u00edxels en cada fotograma. Creem un gestor i un esdeveniment personalitzats per crear objectes de n\u00favol nous a un interval de temps definit de 1000ms. Afegim els objectes de n\u00favols creats a un grup nou anomenat n\u00favols. Actualitzem i dibuixem els n\u00favols al bucle principal del joc. Tingueu en compte que cada n\u00favol i enemic nous s\u2019afegeixen a all_sprites , mentre que els n\u00favols ho fan al grup clouds i els enemics a enemies . Perqu\u00e8? El renderitzat (repintat) es fa amb all_sprites. Les actualitzacions de posici\u00f3 es fan a n\u00favols i enemics. La detecci\u00f3 de col\u00b7lisions es fa entre el jugador i enemics, per\u00f2 no amb n\u00favols, ja que un avi\u00f3 pot atrevessar n\u00favols sense problemes. Per \u00faltim canvieu el color de fons del negre a (135, 206, 250).","title":"Afegir imatges de fons"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/","text":"Efectes de so Fins ara ens hem centrat en el joc i els aspectes visuals del mateix. Ara anem a veure com incorporar sons. pygame proporciona un mesclador per gestionar totes les activitats relacionades amb el so. Utilitzar\u00e0 les classes i m\u00e8todes d\u2019aquest m\u00f2dul per proporcionar m\u00fasica de fons i efectes de so per a diverses accions. El nom de mesclador fa refer\u00e8ncia al fet que el m\u00f2dul barreja diversos sons en un tot cohesionat. Mitjan\u00e7ant el subm\u00f2dul de m\u00fasica, podeu reproduir fitxers de so individuals en diversos formats. Tota la reproducci\u00f3 es produeix en segon pla, de manera que mentre es reprodueix un so, el m\u00e8tode s'executa en paral\u00b7lel i torna el control immediatament al punt on s'ha fet la crida. Inicialitzaci\u00f3 L'\u00fas del mesclador comen\u00e7a amb la seua inicialitzaci\u00f3 pygame.mixer.init() . Si no volem canviar els valors per defecte, no cal passar-li arguments. S'ha d'inicialitzar el mesclador abans que el pygame. Python 1 2 3 4 5 # Setup for sounds. Defaults are good. pygame . mixer . init () # Initialize pygame pygame . init () M\u00fasica de fons Una vegada inicialitzat el sistema, podeu configurar els vostres sons i m\u00fasica de fons com es mostra a continuaci\u00f3. Python 1 2 3 4 5 6 7 8 9 # Load and play background music pygame . mixer . music . load ( \"Apoxode_-_Electric_1.ogg\" ) pygame . mixer . music . play ( loops =- 1 ) # Load all sound files # Sound sources: Jon Fincher move_up_sound = pygame . mixer . Sound ( \"Rising_putter.ogg\" ) move_down_sound = pygame . mixer . Sound ( \"Falling_putter.ogg\" ) collision_sound = pygame . mixer . Sound ( \"Collision.ogg\" ) Carreguen un clip de so de fons i comencen a reproduir-lo. Podeu dir al clip de so que es reproduisca en bucle i que no acabe mai establint el par\u00e0metre loop = -1 . Sons d'esdeveniments Despr\u00e9s carreguen tres sons que farem servir per a diversos efectes de so. Els dos primers s\u00f3n sons ascendents i descendents, que es reprodueixen quan el jugador es mou cap amunt o cap avall. L\u2019\u00faltim \u00e9s el so que s\u2019utilitza sempre que hi ha una col\u00b7lisi\u00f3. Tamb\u00e9 podeu afegir altres sons, com ara un so per a la creaci\u00f3 d'un enemic o un so final per a la finalitzaci\u00f3 del joc. Llavors, com s\u2019utilitzen els efectes de so? Volem reproduir cada so quan es produeixi un esdeveniment determinat. Per exemple, quan l'avi\u00f3 es mou cap amunt, volem reproduir move_up_sound. Per tant, afegiu una crida a .play() sempre que gestioneu este l'esdeveniment. Per a una col\u00b7lisi\u00f3 entre el jugador i un enemic, reprodu\u00efu el so Collisions.ogg . Utilitzeu el m\u00e8tode stop() quan vulgau parar un so que encara s'est\u00e0 reproduint i no voleu que es mescle amb un nou. Fi del joc Finalment, quan acabe el joc, tots els sons haurien de parar-se. Per fer-ho, afegiu les l\u00ednies seg\u00fcents al final del programa despr\u00e9s del bucle: Python 1 2 3 # All done! Stop and quit the mixer. pygame . mixer . music . stop () pygame . mixer . quit () T\u00e8cnicament, aquestes \u00faltimes l\u00ednies no s\u00f3n necess\u00e0ries, ja que el programa finalitza i els recursos s'alliberen. No obstant aix\u00f2, si m\u00e9s endavant decidiu afegir una pantalla d'introducci\u00f3 o una pantalla d'eixida al vostre joc, \u00e9s possible que hi haja m\u00e9s codi executat-se despr\u00e9s que finalitze el joc.","title":"Sons"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/#efectes-de-so","text":"Fins ara ens hem centrat en el joc i els aspectes visuals del mateix. Ara anem a veure com incorporar sons. pygame proporciona un mesclador per gestionar totes les activitats relacionades amb el so. Utilitzar\u00e0 les classes i m\u00e8todes d\u2019aquest m\u00f2dul per proporcionar m\u00fasica de fons i efectes de so per a diverses accions. El nom de mesclador fa refer\u00e8ncia al fet que el m\u00f2dul barreja diversos sons en un tot cohesionat. Mitjan\u00e7ant el subm\u00f2dul de m\u00fasica, podeu reproduir fitxers de so individuals en diversos formats. Tota la reproducci\u00f3 es produeix en segon pla, de manera que mentre es reprodueix un so, el m\u00e8tode s'executa en paral\u00b7lel i torna el control immediatament al punt on s'ha fet la crida.","title":"Efectes de so"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/#inicialitzacio","text":"L'\u00fas del mesclador comen\u00e7a amb la seua inicialitzaci\u00f3 pygame.mixer.init() . Si no volem canviar els valors per defecte, no cal passar-li arguments. S'ha d'inicialitzar el mesclador abans que el pygame. Python 1 2 3 4 5 # Setup for sounds. Defaults are good. pygame . mixer . init () # Initialize pygame pygame . init ()","title":"Inicialitzaci\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/#musica-de-fons","text":"Una vegada inicialitzat el sistema, podeu configurar els vostres sons i m\u00fasica de fons com es mostra a continuaci\u00f3. Python 1 2 3 4 5 6 7 8 9 # Load and play background music pygame . mixer . music . load ( \"Apoxode_-_Electric_1.ogg\" ) pygame . mixer . music . play ( loops =- 1 ) # Load all sound files # Sound sources: Jon Fincher move_up_sound = pygame . mixer . Sound ( \"Rising_putter.ogg\" ) move_down_sound = pygame . mixer . Sound ( \"Falling_putter.ogg\" ) collision_sound = pygame . mixer . Sound ( \"Collision.ogg\" ) Carreguen un clip de so de fons i comencen a reproduir-lo. Podeu dir al clip de so que es reproduisca en bucle i que no acabe mai establint el par\u00e0metre loop = -1 .","title":"M\u00fasica de fons"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/#sons-desdeveniments","text":"Despr\u00e9s carreguen tres sons que farem servir per a diversos efectes de so. Els dos primers s\u00f3n sons ascendents i descendents, que es reprodueixen quan el jugador es mou cap amunt o cap avall. L\u2019\u00faltim \u00e9s el so que s\u2019utilitza sempre que hi ha una col\u00b7lisi\u00f3. Tamb\u00e9 podeu afegir altres sons, com ara un so per a la creaci\u00f3 d'un enemic o un so final per a la finalitzaci\u00f3 del joc. Llavors, com s\u2019utilitzen els efectes de so? Volem reproduir cada so quan es produeixi un esdeveniment determinat. Per exemple, quan l'avi\u00f3 es mou cap amunt, volem reproduir move_up_sound. Per tant, afegiu una crida a .play() sempre que gestioneu este l'esdeveniment. Per a una col\u00b7lisi\u00f3 entre el jugador i un enemic, reprodu\u00efu el so Collisions.ogg . Utilitzeu el m\u00e8tode stop() quan vulgau parar un so que encara s'est\u00e0 reproduint i no voleu que es mescle amb un nou.","title":"Sons d'esdeveniments"},{"location":"unitats/python/pr%C3%A0ctiques/5%20-%20So/#fi-del-joc","text":"Finalment, quan acabe el joc, tots els sons haurien de parar-se. Per fer-ho, afegiu les l\u00ednies seg\u00fcents al final del programa despr\u00e9s del bucle: Python 1 2 3 # All done! Stop and quit the mixer. pygame . mixer . music . stop () pygame . mixer . quit () T\u00e8cnicament, aquestes \u00faltimes l\u00ednies no s\u00f3n necess\u00e0ries, ja que el programa finalitza i els recursos s'alliberen. No obstant aix\u00f2, si m\u00e9s endavant decidiu afegir una pantalla d'introducci\u00f3 o una pantalla d'eixida al vostre joc, \u00e9s possible que hi haja m\u00e9s codi executat-se despr\u00e9s que finalitze el joc.","title":"Fi del joc"},{"location":"unitats/python/pr%C3%A0ctiques/6%20-%20Conclusi%C3%B3/","text":"Conclusi\u00f3 Al llarg d\u2019aquesta pr\u00e0ctica, hem apr\u00e8s els fonaments de la programaci\u00f3 de jocs amb pygame. Concretament: Implementar bucles d'esdeveniments Dibuixar elements a la pantalla Reproduir efectes de so i m\u00fasica Gestionar l'entrada de l'usuari Per fer-ho, hem utilitzat un subconjunt dels m\u00f2duls Pygame, inclosos els m\u00f2duls de visualitzaci\u00f3, mesclador i m\u00fasica, hora, imatge i esdeveniment. Tamb\u00e9 hem utilitzat diverses classes, inclosos Rect, Surface, Sound i Sprite. Per\u00f2 aix\u00f2 nom\u00e9s \u00e9s una xicoteta part del que pot fer Pygame. Consulteu la documentaci\u00f3 oficial de Pygame per obtenir una llista completa de m\u00f2duls i classes disponibles.","title":"Conclusi\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/6%20-%20Conclusi%C3%B3/#conclusio","text":"Al llarg d\u2019aquesta pr\u00e0ctica, hem apr\u00e8s els fonaments de la programaci\u00f3 de jocs amb pygame. Concretament: Implementar bucles d'esdeveniments Dibuixar elements a la pantalla Reproduir efectes de so i m\u00fasica Gestionar l'entrada de l'usuari Per fer-ho, hem utilitzat un subconjunt dels m\u00f2duls Pygame, inclosos els m\u00f2duls de visualitzaci\u00f3, mesclador i m\u00fasica, hora, imatge i esdeveniment. Tamb\u00e9 hem utilitzat diverses classes, inclosos Rect, Surface, Sound i Sprite. Per\u00f2 aix\u00f2 nom\u00e9s \u00e9s una xicoteta part del que pot fer Pygame. Consulteu la documentaci\u00f3 oficial de Pygame per obtenir una llista completa de m\u00f2duls i classes disponibles.","title":"Conclusi\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/1%20-%20Obligatori/","text":"Part obligat\u00f2ria. Pr\u00e0ctica. (30%) Seguix la pr\u00e0ctica pas a pas i construeix el codi del joc. Per fer-ho seguix el mateix ordre que es va explicant al llarg de la pr\u00e0ctica i ves provant els canvis que vas introduint.","title":"Part obligat\u00f2ria (30%)"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/1%20-%20Obligatori/#part-obligatoria-practica-30","text":"Seguix la pr\u00e0ctica pas a pas i construeix el codi del joc. Per fer-ho seguix el mateix ordre que es va explicant al llarg de la pr\u00e0ctica i ves provant els canvis que vas introduint.","title":"Part obligat\u00f2ria. Pr\u00e0ctica. (30%)"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/2%20-%20Projecte/","text":"Part d'ampliaci\u00f3. Projecte. (70%) En esta segona part pots escollir entre dues opcions: Primera opci\u00f3 . Amplia la funcionalitat del joc dels avions: La primera ampliaci\u00f3 proposada \u00e9s un sistema de puntuacions que ser\u00e0 visible a la pantalla del joc. Cada vegada que s'esquive un m\u00edssil i aquest sobrepasse la part esquerra de la pantalla, es sumaran 10 punts al marcador. La segona ampliaci\u00f3 ser\u00e0 que el joc anir\u00e0 canviant cada 20 segons entre el dia i la nit , \u00e9s a dir, el fons canviar\u00e0 del blau del dia al negre de la nit autom\u00e0ticament. La tercera ampliaci\u00f3 ser\u00e0 un sistema de nivells . Cada vegada que el jugador supere un m\u00faltiple de 500 punts, el joc canviar\u00e0 a un nivell superior, comen\u00e7ant la partida en el nivell 1. A m\u00e9s, el nivell ser\u00e0 visible en la pantalla, al costat de la puntuaci\u00f3. La quarta ampliaci\u00f3 ser\u00e0 que la dificultat del joc anir\u00e0 creixent amb els nivells. Al principi del joc, es crearan enemics cada 500ms i la seua velocitat ser\u00e0 un n\u00famero aleatori entre 1 i 10. En el segon nivell, la velocitat de creaci\u00f3 seran 450 ms i les velocitats aniran entre 3 i 12. La idea \u00e9s parametritzar els valors segons el nivell, per exemple, per a la velocitat de creaci\u00f3 podria ser: \\[v_c = 100 + (450 - 50 * nivell)\\] \\[v_e = random(2 * nivell, 10 + 3 * nivell)\\] On \\(v_c\\) \u00e9s la velocitat de creaci\u00f3 d'enemics On \\(v_e\\) \u00e9s la velocitat de despla\u00e7ament dels enemics Fes que la puntuaci\u00f3, en cas de ser un nou r\u00e8cord, es guarde en un document de text anomenat punt_max.txt en la mateixa carpeta on est\u00e0 el codi del joc. Per a saber si \u00e9s un nou r\u00e8cord, quan es carrega el joc, haur\u00e0 de llegir el document i extraure la puntuaci\u00f3 m\u00e0xima. Afegeix una pantalla de benvinguda on es done la benvinguda al joc. A m\u00e9s, ha de mostrar el r\u00e8cord fins al moment i esperar fins que es polse la tecla p, moment en que es passar\u00e0 a la pantalla de joc. Fes una pantalla final on s'indique que la partida ha finalitzat, mostre la puntuaci\u00f3 i el nivell al que s'ha arribat, i en cas de ser r\u00e8cord, ho indique i felicite el jugador. Proposeu una funcionalitat extra al joc per fer-lo m\u00e9s interessant. Qualsevol funcionalitat que resulte interessant ser\u00e0 valorada positivament. Segona opci\u00f3 . Proposa la creaci\u00f3 d'un joc del teu gust del tipus que hem desenvolupat en la pr\u00e0ctica. Pots pensar en jocs tipus el Pong, el Tetris, ... Si agafes aquesta opci\u00f3 conta-li-la al professor abans de comen\u00e7ar a desenvolupar perqu\u00e8 et done l'aprovaci\u00f3 de la idea, ja que pot implicar una dificultat massa elevada o massa baixa. El joc hauria d'incloure tots els tractaments que hem anat desenvolupant durant la pr\u00e0ctica.","title":"Part d'ampliaci\u00f3 - projecte (70%)"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/2%20-%20Projecte/#part-dampliacio-projecte-70","text":"En esta segona part pots escollir entre dues opcions: Primera opci\u00f3 . Amplia la funcionalitat del joc dels avions: La primera ampliaci\u00f3 proposada \u00e9s un sistema de puntuacions que ser\u00e0 visible a la pantalla del joc. Cada vegada que s'esquive un m\u00edssil i aquest sobrepasse la part esquerra de la pantalla, es sumaran 10 punts al marcador. La segona ampliaci\u00f3 ser\u00e0 que el joc anir\u00e0 canviant cada 20 segons entre el dia i la nit , \u00e9s a dir, el fons canviar\u00e0 del blau del dia al negre de la nit autom\u00e0ticament. La tercera ampliaci\u00f3 ser\u00e0 un sistema de nivells . Cada vegada que el jugador supere un m\u00faltiple de 500 punts, el joc canviar\u00e0 a un nivell superior, comen\u00e7ant la partida en el nivell 1. A m\u00e9s, el nivell ser\u00e0 visible en la pantalla, al costat de la puntuaci\u00f3. La quarta ampliaci\u00f3 ser\u00e0 que la dificultat del joc anir\u00e0 creixent amb els nivells. Al principi del joc, es crearan enemics cada 500ms i la seua velocitat ser\u00e0 un n\u00famero aleatori entre 1 i 10. En el segon nivell, la velocitat de creaci\u00f3 seran 450 ms i les velocitats aniran entre 3 i 12. La idea \u00e9s parametritzar els valors segons el nivell, per exemple, per a la velocitat de creaci\u00f3 podria ser: \\[v_c = 100 + (450 - 50 * nivell)\\] \\[v_e = random(2 * nivell, 10 + 3 * nivell)\\] On \\(v_c\\) \u00e9s la velocitat de creaci\u00f3 d'enemics On \\(v_e\\) \u00e9s la velocitat de despla\u00e7ament dels enemics Fes que la puntuaci\u00f3, en cas de ser un nou r\u00e8cord, es guarde en un document de text anomenat punt_max.txt en la mateixa carpeta on est\u00e0 el codi del joc. Per a saber si \u00e9s un nou r\u00e8cord, quan es carrega el joc, haur\u00e0 de llegir el document i extraure la puntuaci\u00f3 m\u00e0xima. Afegeix una pantalla de benvinguda on es done la benvinguda al joc. A m\u00e9s, ha de mostrar el r\u00e8cord fins al moment i esperar fins que es polse la tecla p, moment en que es passar\u00e0 a la pantalla de joc. Fes una pantalla final on s'indique que la partida ha finalitzat, mostre la puntuaci\u00f3 i el nivell al que s'ha arribat, i en cas de ser r\u00e8cord, ho indique i felicite el jugador. Proposeu una funcionalitat extra al joc per fer-lo m\u00e9s interessant. Qualsevol funcionalitat que resulte interessant ser\u00e0 valorada positivament. Segona opci\u00f3 . Proposa la creaci\u00f3 d'un joc del teu gust del tipus que hem desenvolupat en la pr\u00e0ctica. Pots pensar en jocs tipus el Pong, el Tetris, ... Si agafes aquesta opci\u00f3 conta-li-la al professor abans de comen\u00e7ar a desenvolupar perqu\u00e8 et done l'aprovaci\u00f3 de la idea, ja que pot implicar una dificultat massa elevada o massa baixa. El joc hauria d'incloure tots els tractaments que hem anat desenvolupant durant la pr\u00e0ctica.","title":"Part d'ampliaci\u00f3. Projecte. (70%)"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/3%20-%20Qualificaci%C3%B3/","text":"Qualificaci\u00f3 Per a qualificar aquesta primera unitat, es valorar\u00e0 un 30% la part de pr\u00e0ctica obligat\u00f2ria i un 70% la part del projecte o ampliaci\u00f3. Per a la part del projecte s'utilitzar\u00e0 una r\u00fabrica que es posar\u00e0 a disposici\u00f3 dels alumnes abans de comen\u00e7ar el desenvolupament. D'esta forma, l'alumne podr\u00e0 saber anticipadament, els aspectes que es tindran en compte a l'hora de corregir. (Sols per a alumnes del presencial) A m\u00e9s, es realitzar\u00e0 una coavaluaci\u00f3. Per a fer a\u00e7\u00f2, cada alumne exposar\u00e0 en un per\u00edode breu, al voltant de 5 minuts el seu projecte, i la resta d'alumnes l'avaluaran.","title":"Qualificaci\u00f3"},{"location":"unitats/python/pr%C3%A0ctiques/tasques/3%20-%20Qualificaci%C3%B3/#qualificacio","text":"Per a qualificar aquesta primera unitat, es valorar\u00e0 un 30% la part de pr\u00e0ctica obligat\u00f2ria i un 70% la part del projecte o ampliaci\u00f3. Per a la part del projecte s'utilitzar\u00e0 una r\u00fabrica que es posar\u00e0 a disposici\u00f3 dels alumnes abans de comen\u00e7ar el desenvolupament. D'esta forma, l'alumne podr\u00e0 saber anticipadament, els aspectes que es tindran en compte a l'hora de corregir. (Sols per a alumnes del presencial) A m\u00e9s, es realitzar\u00e0 una coavaluaci\u00f3. Per a fer a\u00e7\u00f2, cada alumne exposar\u00e0 en un per\u00edode breu, al voltant de 5 minuts el seu projecte, i la resta d'alumnes l'avaluaran.","title":"Qualificaci\u00f3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/","text":"Introducci\u00f3 a Python Comen\u00e7ant amb Python Qu\u00e8 \u00e9s Python? Python \u00e9s un llenguatge de prop\u00f2sit general, al igual que Java o C. El seu \u00fas ha augmentat durant els \u00faltims temps gr\u00e0cies a: La seua flexibilitat i simplicitat, que el fan f\u00e0cil d'aprendre El seu \u00fas extens en camps com el \"Data Science\", la IA i l'aprenentatge de programaci\u00f3. Llenguatge d'scripting d'alt nivell. Multiplataforma. Gran quantitat i varietat de llibreries. Web frameworks, clients correu, gestors de contingut, concurr\u00e8ncia, generaci\u00f3 de documents, gr\u00e0fics, intel\u00b7lig\u00e8ncia artificial, ... Lliure!! Mant\u00e9s per la Python Software Foundation Execuci\u00f3 de Python Perqu\u00e8 Python El llenguatge de programaci\u00f3 Python \u00e9s una opci\u00f3 cada vegada m\u00e9s utilitzada per principiants com per desenvolupadors experimentats. Flexible i vers\u00e0til, Python t\u00e9 punts forts en scripts, automatitzaci\u00f3, an\u00e0lisi de dades, aprenentatge autom\u00e0tic i desenvolupament de back-end. Publicat per primera vegada el 1991 amb un nom inspirat en el grup de com\u00e8dia brit\u00e0nic Monty Python, l\u2019equip de desenvolupament volia fer de Python un llenguatge divertit d\u2019utilitzar. C \u00e9s el llenguatge de programaci\u00f3 m\u00e9s popular a l\u2019\u00edndex TIOBE, mentre que Python \u00e9s el llenguatge m\u00e9s buscat a l\u2019\u00edndex PYPL. Python i Java segueixen de prop a C al TIOBE. A PYPL, la difer\u00e8ncia \u00e9s m\u00e9s gran, ja que Python, que ocupa el primer lloc, supera en un 12% a Java, que ocupa el segon lloc. Aquest curs, aprendrem a utilitzar Python i el framework Qt per desenvolupar aplicacions amb interf\u00edcie d'usuari. Instal\u00b7laci\u00f3 de Python 3 Anem a instal\u00b7lar a l'Ubuntu 20.04 un entorn de programaci\u00f3 Python 3, encara que valdr\u00e0 per a qualsevol distribuci\u00f3 basada en Debian Linux, com \u00e9s el cas. En cas d'utilitzar Windows o MacOS, busqueu la forma d'instal\u00b7lar-lo. Requisits previs Per poder instal\u00b7lar, haureu de tindre un usuari amb privilegis sudo en l'Ubuntu 20.04. Primer pas - Configurant Python 3 Ubuntu 20.04 ja inclou Python 3 preinstal\u00b7lat. Per assegurar-nos que les nostres versions estan actualitzades, actualitzem els repositoris i actualitzem el sistema amb l'ordre apt: Bash 1 2 $ sudo apt update $ sudo apt -y upgrade L'opci\u00f3 -y confirmar\u00e0 que estem d'acord per instal\u00b7lar totes les actualitzacions, per\u00f2, segons la vostra versi\u00f3 de Linux, \u00e9s possible que h\u00e0giu de confirmar les sol\u00b7licituds addicionals. Una vegada finalitzat el proc\u00e9s, podem comprovar la versi\u00f3 de Python 3 que s\u2019instal\u00b7la al sistema escrivint: Bash 1 2 $ python3 -V Python 3 .8.10 El terminal vos indicar\u00e0 el n\u00famero de versi\u00f3. No es tracta de l'\u00faltima versi\u00f3 estable de Python (3.9.7), per\u00f2 si de la \u00faltima disponibles als repositoris d'Ubuntu. Per gestionar paquets de programari per a Python, instal\u00b7leu pip, una eina que instal\u00b7lar\u00e0 i gestionar\u00e0 paquets de programaci\u00f3 que \u00e9s possible que vulguem utilitzar en els nostres projectes de desenvolupament. Bash 1 $ sudo apt install -y python3-pip Ara podrem utilitzar pip3 per instal\u00b7lar paquets de Python3. Bash 1 $ pip3 install \"paquet\" A m\u00e9s, instl\u00b7larem algunes llibreries necess\u00e0ries per a la construcci\u00f3 dels nostres m\u00f2duls i extensions. Bash 1 $ sudo apt install -y build-essential libssl-dev libffi-dev python3-dev Segon pas - Configurem un entorn virtual de desenvolupament Els entorns virtuals ens permeten tenir un espai a\u00efllat per a desenvolupament de projectes Python, cosa que garanteix que cadascun dels vostres projectes puga tindre el seu propi conjunt de depend\u00e8ncies que no interrompin cap dels vostres altres projectes. Configurar un entorn de programaci\u00f3 proporciona un major control sobre els projectes de Python i sobre com es gestionen les diferents versions dels paquets. Aix\u00f2 \u00e9s especialment important quan es treballa amb paquets de tercers. Podeu configurar tants entorns de programaci\u00f3 Python com vulgueu. Cada entorn \u00e9s b\u00e0sicament un directori que cont\u00e9 uns quants scripts per fer-lo actuar com a entorn a\u00efllat de la resta de programes i llibreries de l'ordinador. Tot i que hi ha algunes maneres d\u2019aconseguir un entorn de programaci\u00f3 a Python, farem servir el m\u00f2dul venv, que forma part de la biblioteca est\u00e0ndard de Python 3. Instal\u00b7lem venv escrivint: Bash 1 $ sudo apt install -y python3-venv Amb a\u00e7\u00f2, estem preparats per crear entorns virtuals (virtual environments) . Trieu en quin directori volem situar els nostres entorns de programaci\u00f3 Python o b\u00e9 creeu un directori nou amb mkdir: Bash 1 2 $ mkdir environments $ cd environments Una vegada esteu al directori on voleu que es creen els entorns, podeu crear un entorn executant l'ordre seg\u00fcent: Bash 1 $ python3 -m venv my_env Essencialment, pyvenv crea un nou directori que cont\u00e9 alguns elements: Bash 1 bin include lib lib64 pyvenv.cfg share Junts, aquests fitxers funcionen per assegurar-vos que els vostres projectes estiguen a\u00efllats, de manera que els fitxers del sistema i els fitxers de projecte no es mesclen i entren en conflicte. Aquesta \u00e9s una bona pr\u00e0ctica per al control de versions i per garantir que cadascun dels vostres projectes tinga acc\u00e9s als paquets particulars que necessita. Per utilitzar aquest entorn, l'heu d'activar, cosa que podeu aconseguir escrivint l'ordre seg\u00fcent que crida a l'script d'activaci\u00f3: Bash 1 $ source my_env/bin/activate El vostre indicador d\u2019ordres ara tindr\u00e0 el prefix amb el nom del vostre entorn, en aquest cas s\u2019anomena my_env. Depenent de la versi\u00f3 de Debian Linux que utilitzeu, el vostre prefix pot apar\u00e8ixer de manera diferent, per\u00f2 el nom del vostre entorn entre par\u00e8ntesis hauria de ser el primer que veieu a la vostra l\u00ednia: Aquest prefix ens permet saber que l\u2019entorn my_env est\u00e0 actiu actualment, \u00e9s a dir, que quan creem programes aqu\u00ed, nom\u00e9s utilitzaran la configuraci\u00f3 i els paquets d\u2019aquest entorn concret. Nota: a l\u2019entorn virtual, podeu utilitzar l\u2019ordre python en lloc de python3 i pip en lloc de pip3 si ho preferiu. Si utilitzeu Python 3 a la vostra m\u00e0quina fora d\u2019un entorn, haureu d\u2019utilitzar exclusivament les ordres python3 i pip3. Despr\u00e9s de seguir aquests passos, el vostre entorn virtual ja es pot utilitzar. Per a desactivar l'entorn virtual, simplement tanquem la consola o utilitzem l'ordre deactivate . Deapareixer\u00e0 el nom de l'entorn virtual abans del prompt. Modes d'execuci\u00f3 Interactiva a trav\u00e9s de l'int\u00e8rpret Bash 1 2 3 4 5 ~$ python3 Python 3 .7.3 ( default, Jul 25 2020 , 13 :03:44 ) [ GCC 8 .3.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Execuci\u00f3 d'un fitxer Python Bash 1 2 ~$ python3 hola_mon.py Hola m\u00f3n Execuci\u00f3 d'un script Bash 1 2 3 4 5 6 7 8 9 hola_mon.py --- #!/usr/bin/env python3 print ( \"Hola m\u00f3n\" ) --- ~$ chmod u+x hola_mon.py ~$ ./hola_mon.py Hola m\u00f3n Des d'un Entorn de Desenvolupament IDE Activitat 1 Implementa el \"Hola m\u00f3n!\" i executa-lo de les quatre formes possibles. Paraules reservades i identificadors Paraules reservades No es poden utilitzar coma identificador de variables ni nom de funcions, ja que s'utilitzen per a definir la sintaxi i l'estructura d'un programa. Les paraules reservades s\u00f3n: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Per a obtindre la llista completa des de l'int\u00e8rpret: Python 1 2 >>> import keyword >>> print ( keyword . kwlist ) Identificadors Per convenci\u00f3, els noms de les variables i funcions han de ser: combinacions de lletres min\u00fascules i n\u00fameros comen\u00e7ar per lletra descriptius (excepte en bucles o se sol utilitzar i i j ) amb paraules separades per gui\u00f3 baix Per exemple: nom_usuari, numero_telefon, cognom1, sumar(), ... Recorda que Python \u00e9s un llenguatge case sensitive . Per tant Var i var no s\u00f3n el mateix identificador. Instruccions i sagnat Instruccions L'int\u00e8rpret de Python va executant l\u00ednia a l\u00ednia cada instrucci\u00f3. Si volem que una instrucci\u00f3 ocupe diverses l\u00ednies ho hem d'indicar amb el car\u00e0cter \\. Per exemple: Python 1 2 3 4 5 >>> a = 1 + 2 + 3 + \\ ... 4 + 5 + 6 + \\ ... 7 + 8 + 9 >>> print ( a ) 45 La continuaci\u00f3 de l\u00ednia \u00e9s implicita dins de par\u00e8ntesis (), corxets [] i claus {}. Python 1 2 3 colors = [ 'red' , 'blue' , 'green' ] Tamb\u00e9 podem posar diverses sent\u00e8ncies en una l\u00ednia: Python 1 a = 1 ; b = 2 ; c = 3 Sagnat La majoria de llenguatges de programaci\u00f3 utilitzen les claus {} per a definir blocs de codi. En canvi, Python utilitza el sagnat (identation). Un bloc de codi (cos d'una funci\u00f3, bucle, etc.) comen\u00e7a amb sagnat i acaba amb la primera l\u00ednia sense sagnat. Dep\u00e8n de vosaltres la quantitat de sagnat, per\u00f2 ha de ser coherent en tot el bloc. Generalment, s\u2019utilitzen quatre espais en blanc per a sagnat i es prefereixen a les tabulacions. El resultat \u00e9s un codi net i clar. Exemple: Python 1 2 3 4 for i in range ( 1 , 11 ): print ( i ) if i == 5 : break Un sagnat incorrecte llan\u00e7a un IndentationError . Comentaris Els comentaris s\u00f3n molt importants en escriure un programa. Descriuen el que passa dins d\u2019un programa, de manera que una persona que mira el codi font no tinga dificultats per entendre'l. A m\u00e9s, \u00e9s possible que oblideu els detalls clau d'implementaci\u00f3 del programa que acabeu d\u2019escriure. Per tant, invertir temps per explicar aquests conceptes en forma de comentaris sempre \u00e9s fruct\u00edfer . A Python, fem servir el s\u00edmbol coixinet (#) per comen\u00e7ar a escriure un comentari. S'est\u00e9n fins al car\u00e0cter de l\u00ednia nova. No cal que el comentari estiga a principi de l\u00ednia, pot estar en mig. Per fer comentaris multil\u00ednia, podem utilitzar el coixinet a principi de cada l\u00ednia. Tamb\u00e9 podem fer servir les cometes dobles o simples tres vegades. Exemple: Python 1 2 ''' Comentari multil\u00ednia''' Docstrings Una docstring \u00e9s una abreviatura de text de documentaci\u00f3. La documentaci\u00f3 de Python s\u00f3n els textos que apareixen just despr\u00e9s de la definici\u00f3 d'una funci\u00f3, m\u00e8tode, classe o m\u00f2dul. S'utilitzen cometes triples durant l'escriptura de la documentaci\u00f3. Per exemple: Python 1 2 3 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num La documentaci\u00f3 s\u2019associa a l\u2019objecte com a atribut doc . Per tant, podem accedir a la documentaci\u00f3 de la funci\u00f3 anterior amb les seg\u00fcents l\u00ednies de codi: Python 1 2 3 4 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num print ( doble . __ doc__ ) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def suma_binaria ( a , b ): ''' Torna la suma de dos enters en binari. Par\u00e0metres: a (int): Un enter b (int): Altre enter Torna: suma_binaria (str): String amb els digits binaris de la suma ''' suma_binaria = bin ( a + b )[ 2 :] return suma_binaria print ( suma_binaria . __doc__ ) Variables, constants i tipus Variables En Python, quan declarem una variable i li assignem un valor, realment estem creant un objecte i assignant un valor per refer\u00e8ncia. Python 1 2 3 4 5 6 >>> num = 10 >>> type ( num ) < class ' int '> >>> num = 10.0 >>> type ( num ) < class ' float '> Podem inicialitzar m\u00faltiples variables en una mateixa l\u00ednia, ja siga amb el mateix valor o diferent. Python 1 2 a , b , c = 5 , 3.2 , \"Hola\" x = y = z = \"iguals\" Constants A Python no existeixen les constants a l'estil de static final de Java, sin\u00f3 que simplement es defineix una variable que no es modifica el valor. Normalment es definixen en un m\u00f2dul a banda, utilitzant maj\u00fascules i gui\u00f3 baix si \u00e9s necessari, que s'importa a l'arxiu principal. Python 1 2 3 4 5 6 7 8 9 10 constants . py --- PI = 3.14 main . py --- import constants.py radi = 5 perimetre = 2 * constants . PI * radi print ( perimetre ) Tipus L'assignaci\u00f3 de tipus \u00e9s din\u00e0mica i pot canviar, per aix\u00f2 no declarem els tipus de les variables. Per determinar el tipus d'un objecte, fem servir el m\u00e8tode type() . Els tipus d'objecte definits a Python3 s\u00f3n: 1. Num\u00e8rics: 1.1. Integer Python 1 2 3 4 a = 0b1010 #Binary b = 100 #Decimal c = 0o310 #Octal d = 0x12c #Hexadecimal 1.2. Float Python 1 2 float_1 = 10.5 float_2 = 1.5e2 1.3. Complex Python 1 x = 3 + 4 j Strings Python 1 nom = 'Ferran Cunyat' Els principals m\u00e8todes sobre un string s\u00f3n capitalize(), count(), find(), format(), lower(), replace(), split(), title(), translate(), upper() . Boolean Python 1 2 3 4 x = ( 1 == True ) # True pren el valor num\u00e8ric 1, mentre que False el 0 y = ( 1 == False ) a = True + 4 b = False + 10 Especials (None) S'utilitza per no donar-li valor a una variable. Python 1 2 3 >>> x = None >>> type ( x ) < class ' NoneType '> Col\u00b7leccions Llista S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, encara que normalment si que ho s\u00f3n. Es definix amb corxets i els elements separats per comes. Podem accedir a un element o un rang i \u00e9s mutable. Python 1 2 3 4 5 6 >>> a = [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> print ( a ) [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> a [ 3 ] = \"Ferran\" >>> print ( a [: 4 ]) [ 5 , 10 , 15 , 'Ferran' ] Algunes de les principals funcions que podem aplicar sobre llistes s\u00f3n apend(), clear(), copy(), extend(), insert(), remove(), reverse() . Tupla S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, per\u00f2 esta vegada immutable. Python 1 2 3 4 5 >>> tupla = ( 2 , 'hola' ) >>> tupla [ 1 ] = 'clavel' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Rang Seq\u00fc\u00e8ncia immutable de n\u00fameros, generalment utilitzada per a iterar sobre for o generar llistes r\u00e0pidament. Python 1 2 >>> list ( range ( 0 , 30 , 5 )) [ 0 , 5 , 10 , 15 , 20 , 25 ] 3 . Conjunt (Set) Col\u00b7lecci\u00f3 desordenada d'elements \u00fanics. Ja que \u00e9s una llista desordenada, no la podem indexar i per tant accedir als elements segons la seua posici\u00f3. Python 1 2 3 4 5 6 7 8 >>> a = { 2 , 2 , 5 , 5 , 4 , 10 , 1 , 0 } >>> print ( a ) { 0 , 1 , 2 , 4 , 5 , 10 } >>> a [ 1 ] Traceback ( most recent call last ): File \"<string>\" , line 301 , in runcode File \"<interactive input>\" , line 1 , in < module > TypeError : 'set' object does not support indexing Diccionari Diccionari \u00e9s una col\u00b7lecci\u00f3 no ordenada de parells valor-clau. Generalment s\u2019utilitza quan tenim una gran quantitat de dades. Els diccionaris estan optimitzats per recuperar dades. Hem de con\u00e8ixer la clau per recuperar el valor. A Python, els diccionaris es defineixen entre claus {} i cada element \u00e9s un parell que adopta la forma de clau:valor. La clau i el valor poden ser de qualsevol tipus. Python 1 2 3 4 5 6 7 8 9 10 11 >>> d = { 1 : 'valor' , 'clau' : 2 } >>> print ( type ( d )) < class ' dict '> >>> print ( \"d[1] = \" , d [ 1 ]); d [ 1 ] = valor >>> print ( \"d['clau'] = \" , d [ 'clau' ]); d [ 'clau' ] = 2 >>> print ( \"d[2] = \" , d [ 2 ]); Traceback ( most recent call last ): File \"<stdin>\" , line 2 , in < module > KeyError : 2 Activitat 2 Fixa't en el seg\u00fcent fragment de codi: Python 1 2 3 4 5 6 7 8 9 >>> s = [ 1 , 2 ] >>> r = s [:] >>> s [ 0 ] = 2 >>> print ( s ) [ 2 , 2 ] >>> print ( r ) ??? >>> print ( s ) ??? Quina ser\u00e0 l'eixida? Per qu\u00e9? Python 1 2 3 4 5 6 >>> r = s >>> s [ 0 ] = 5 >>> print ( r ) ??? >>> print ( s ) ??? I ara? Per qu\u00e9? Conversi\u00f3 entre tipus Conversi\u00f3 impl\u00edcita S\u00f3n conversions que fa el mateix llenguatge autom\u00e0ticament. Per exemple: Python 1 2 3 4 5 6 7 8 9 10 num_int = 123 num_flo = 1.23 num_nou = num_int + num_flo print ( \"num_int \u00e9s de tipus:\" , type ( num_int )) print ( \"num_flo \u00e9s de tipus:\" , type ( num_flo )) print ( \"Valor de num_nou:\" , num_nou ) print ( \"num_nou \u00e9s de tipus:\" , type ( num_nou )) Conversi\u00f3 expl\u00edcita Utilitzem funcions predefinides per a for\u00e7ar la conversi\u00f3 int(), float(), str(), ... . Activitat 3 Quin \u00e9s el resultat d'executar el seg\u00fcent fragment de codi? Python 1 2 3 >>> enter = 123 >>> cadena = \"456\" >>> suma = enter + cadena Definix dues variables, una per a fer la suma entera (579) i l'altra per a concatrenar com a text (123456). Entrada, eixida i import Entrada Ja hem vist que per a introduir informaci\u00f3 per teclat utilitzem la funci\u00f3 input([prompt]) . Eixida Per a imprimir per ella utilitzarem la funci\u00f3 print() . Moltes vegades s'utilitza en combinaci\u00f3 amb la funci\u00f3 format() dels strings. Python 1 2 3 4 5 >>> x = 5 ; y = 10 >>> print ( 'El valor d \\' x \u00e9s {} i el de y \u00e9s {} ' . format ( x , y )) >>> # Fixeu-se que hem escapat el caracter ' El valor d 'x \u00e9s 5 i el de y \u00e9s 10 >>> print ( 'Hola {nom} , {salutacio} ' . format ( salutacio = 'Bon dia' , nom = 'Pau' )) Activitat 4 Implementa el programa \"Hola m\u00f3n\" utilitzant la funci\u00f3 format. Import Quan volem fer \u00fas del codi d'un altre m\u00f2dul (.py), l'hem d'importar al programa actual amb import . Python 1 2 >>> import math >>> print ( math . pi ) Tamb\u00e9 podem importar sols alguna de les funcions o atributs amb from Python 1 >>> from math import pi En importar un m\u00f2dul, Python analitza diversos llocs definits a sys.path. \u00c9s una llista de les ubicacions on buscar el m\u00f2dul. Python 1 2 3 >>> import sys >>> sys . path [ '' , '/usr/lib/python37.zip' , '/usr/lib/python3.7' , '/usr/lib/python3.7/lib-dynload' , '/home/ferran/.local/lib/python3.7/site-packages' , '/usr/local/lib/python3.7/dist-packages' , '/usr/lib/python3/dist-packages' ] Per a importar d'una altra carpeta, ho fem amb from paquet import modul . Pots posar ubicacions absolutes o relatives. Si volem importar un codi d'una ubicaci\u00f3 que no est\u00e0 al path. Python 1 2 >>> import sys >>> sys . path . append ( '/path/a/la/carpeta' ) Espai de noms i \u00e0mbit de variables Noms En Python, tot s\u00f3n objectes, incl\u00fas les funcions. Un nom \u00e9s la forma d'accedir als objectes, i amb la funci\u00f3 id() podem veure la seua ubicaci\u00f3 en mem\u00f2ria. Per exemple: Python 1 2 3 4 5 >>> a = 2 >>> print ( 'id(2) =' , id ( 2 )) id ( 2 ) = 9062656 >>> print ( 'id(a) =' , id ( a )) d ( a ) = 9062656 Activitat 5 Quin creus que ser\u00e0 el resultat a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 >>> a = 2 >>> print ( 'id(a) =' , id ( a )) >>> a = a + 1 >>> print ( 'id(a) =' , id ( a )) >>> print ( 'id(3) =' , id ( 3 )) >>> b = 2 >>> print ( 'id(b) =' , id ( b )) >>> print ( 'id(2) =' , id ( 2 )) Espais de noms (namespaces) Els espais de noms a Python, s\u00f3n una col\u00b7lecci\u00f3 de noms. Diferents espais de noms poden coexistir, per\u00f2 estan completament a\u00efllats. Quan iniciem Python, es crea un espai de noms amb totes les funcions que l'int\u00e8rpret reconeix, espai de noms predefinit . Aquesta \u00e9s la ra\u00f3 per la qual funcions integrades com id (), print () etc. sempre estan disponibles per a nosaltres des de qualsevol part del programa. En canvi, cada m\u00f2dul crea el seu propi espai de noms global . Aquests espais de noms estan a\u00efllats entre ells. Per tant, podem donar el mateix nom a objectes de m\u00f2duls diferents sense que entren en conflicte. Els m\u00f2duls poden contindre funcions i classes. Quan es crida una funci\u00f3, es crea un espai de noms local que t\u00e9 noms propis definits. Similar, \u00e9s el cas de la classe. El seg\u00fcent diagrama pot ajudar a aclarir aquest concepte. \u00c0mbit de les variables Tot i que hi ha diversos espais de noms definits, \u00e9s possible que no puguem accedir a tots ells des de totes les parts del programa. El concepte d\u2019\u00e0mbit entra en joc. Sempre hi ha almenys tres \u00e0mbits definits. \u00c0mbit local a la funci\u00f3 amb nom locals \u00c0mbit del m\u00f2dul que t\u00e9 noms globals \u00c0mbit m\u00e9s extern que t\u00e9 noms predefinits Quan es fa una refer\u00e8ncia dins d'una funci\u00f3, el nom es busca a l'espai de noms local, despr\u00e9s a l'espai de noms global i finalment a l'espai de noms predefinit. Si hi ha una funci\u00f3 dins d\u2019una altra funci\u00f3, s\u2019anida un nou \u00e0mbit dins de l'\u00e0mbit local. Activitat 6 Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def funcio_externa (): a = 20 def funcio_interna (): a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a ) Activitat 7 Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def funcio_externa (): global a a = 20 def funcio_interna (): global a a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Introducci\u00f3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#introduccio-a-python","text":"","title":"Introducci\u00f3 a Python"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#comencant-amb-python","text":"","title":"Comen\u00e7ant amb Python"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#que-es-python","text":"Python \u00e9s un llenguatge de prop\u00f2sit general, al igual que Java o C. El seu \u00fas ha augmentat durant els \u00faltims temps gr\u00e0cies a: La seua flexibilitat i simplicitat, que el fan f\u00e0cil d'aprendre El seu \u00fas extens en camps com el \"Data Science\", la IA i l'aprenentatge de programaci\u00f3. Llenguatge d'scripting d'alt nivell. Multiplataforma. Gran quantitat i varietat de llibreries. Web frameworks, clients correu, gestors de contingut, concurr\u00e8ncia, generaci\u00f3 de documents, gr\u00e0fics, intel\u00b7lig\u00e8ncia artificial, ... Lliure!! Mant\u00e9s per la Python Software Foundation","title":"Qu\u00e8 \u00e9s Python?"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#execucio-de-python","text":"","title":"Execuci\u00f3 de Python"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#perque-python","text":"El llenguatge de programaci\u00f3 Python \u00e9s una opci\u00f3 cada vegada m\u00e9s utilitzada per principiants com per desenvolupadors experimentats. Flexible i vers\u00e0til, Python t\u00e9 punts forts en scripts, automatitzaci\u00f3, an\u00e0lisi de dades, aprenentatge autom\u00e0tic i desenvolupament de back-end. Publicat per primera vegada el 1991 amb un nom inspirat en el grup de com\u00e8dia brit\u00e0nic Monty Python, l\u2019equip de desenvolupament volia fer de Python un llenguatge divertit d\u2019utilitzar. C \u00e9s el llenguatge de programaci\u00f3 m\u00e9s popular a l\u2019\u00edndex TIOBE, mentre que Python \u00e9s el llenguatge m\u00e9s buscat a l\u2019\u00edndex PYPL. Python i Java segueixen de prop a C al TIOBE. A PYPL, la difer\u00e8ncia \u00e9s m\u00e9s gran, ja que Python, que ocupa el primer lloc, supera en un 12% a Java, que ocupa el segon lloc. Aquest curs, aprendrem a utilitzar Python i el framework Qt per desenvolupar aplicacions amb interf\u00edcie d'usuari.","title":"Perqu\u00e8 Python"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#installacio-de-python-3","text":"Anem a instal\u00b7lar a l'Ubuntu 20.04 un entorn de programaci\u00f3 Python 3, encara que valdr\u00e0 per a qualsevol distribuci\u00f3 basada en Debian Linux, com \u00e9s el cas. En cas d'utilitzar Windows o MacOS, busqueu la forma d'instal\u00b7lar-lo.","title":"Instal\u00b7laci\u00f3 de Python 3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#requisits-previs","text":"Per poder instal\u00b7lar, haureu de tindre un usuari amb privilegis sudo en l'Ubuntu 20.04.","title":"Requisits previs"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#primer-pas-configurant-python-3","text":"Ubuntu 20.04 ja inclou Python 3 preinstal\u00b7lat. Per assegurar-nos que les nostres versions estan actualitzades, actualitzem els repositoris i actualitzem el sistema amb l'ordre apt: Bash 1 2 $ sudo apt update $ sudo apt -y upgrade L'opci\u00f3 -y confirmar\u00e0 que estem d'acord per instal\u00b7lar totes les actualitzacions, per\u00f2, segons la vostra versi\u00f3 de Linux, \u00e9s possible que h\u00e0giu de confirmar les sol\u00b7licituds addicionals. Una vegada finalitzat el proc\u00e9s, podem comprovar la versi\u00f3 de Python 3 que s\u2019instal\u00b7la al sistema escrivint: Bash 1 2 $ python3 -V Python 3 .8.10 El terminal vos indicar\u00e0 el n\u00famero de versi\u00f3. No es tracta de l'\u00faltima versi\u00f3 estable de Python (3.9.7), per\u00f2 si de la \u00faltima disponibles als repositoris d'Ubuntu. Per gestionar paquets de programari per a Python, instal\u00b7leu pip, una eina que instal\u00b7lar\u00e0 i gestionar\u00e0 paquets de programaci\u00f3 que \u00e9s possible que vulguem utilitzar en els nostres projectes de desenvolupament. Bash 1 $ sudo apt install -y python3-pip Ara podrem utilitzar pip3 per instal\u00b7lar paquets de Python3. Bash 1 $ pip3 install \"paquet\" A m\u00e9s, instl\u00b7larem algunes llibreries necess\u00e0ries per a la construcci\u00f3 dels nostres m\u00f2duls i extensions. Bash 1 $ sudo apt install -y build-essential libssl-dev libffi-dev python3-dev","title":"Primer pas - Configurant Python 3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#segon-pas-configurem-un-entorn-virtual-de-desenvolupament","text":"Els entorns virtuals ens permeten tenir un espai a\u00efllat per a desenvolupament de projectes Python, cosa que garanteix que cadascun dels vostres projectes puga tindre el seu propi conjunt de depend\u00e8ncies que no interrompin cap dels vostres altres projectes. Configurar un entorn de programaci\u00f3 proporciona un major control sobre els projectes de Python i sobre com es gestionen les diferents versions dels paquets. Aix\u00f2 \u00e9s especialment important quan es treballa amb paquets de tercers. Podeu configurar tants entorns de programaci\u00f3 Python com vulgueu. Cada entorn \u00e9s b\u00e0sicament un directori que cont\u00e9 uns quants scripts per fer-lo actuar com a entorn a\u00efllat de la resta de programes i llibreries de l'ordinador. Tot i que hi ha algunes maneres d\u2019aconseguir un entorn de programaci\u00f3 a Python, farem servir el m\u00f2dul venv, que forma part de la biblioteca est\u00e0ndard de Python 3. Instal\u00b7lem venv escrivint: Bash 1 $ sudo apt install -y python3-venv Amb a\u00e7\u00f2, estem preparats per crear entorns virtuals (virtual environments) . Trieu en quin directori volem situar els nostres entorns de programaci\u00f3 Python o b\u00e9 creeu un directori nou amb mkdir: Bash 1 2 $ mkdir environments $ cd environments Una vegada esteu al directori on voleu que es creen els entorns, podeu crear un entorn executant l'ordre seg\u00fcent: Bash 1 $ python3 -m venv my_env Essencialment, pyvenv crea un nou directori que cont\u00e9 alguns elements: Bash 1 bin include lib lib64 pyvenv.cfg share Junts, aquests fitxers funcionen per assegurar-vos que els vostres projectes estiguen a\u00efllats, de manera que els fitxers del sistema i els fitxers de projecte no es mesclen i entren en conflicte. Aquesta \u00e9s una bona pr\u00e0ctica per al control de versions i per garantir que cadascun dels vostres projectes tinga acc\u00e9s als paquets particulars que necessita. Per utilitzar aquest entorn, l'heu d'activar, cosa que podeu aconseguir escrivint l'ordre seg\u00fcent que crida a l'script d'activaci\u00f3: Bash 1 $ source my_env/bin/activate El vostre indicador d\u2019ordres ara tindr\u00e0 el prefix amb el nom del vostre entorn, en aquest cas s\u2019anomena my_env. Depenent de la versi\u00f3 de Debian Linux que utilitzeu, el vostre prefix pot apar\u00e8ixer de manera diferent, per\u00f2 el nom del vostre entorn entre par\u00e8ntesis hauria de ser el primer que veieu a la vostra l\u00ednia: Aquest prefix ens permet saber que l\u2019entorn my_env est\u00e0 actiu actualment, \u00e9s a dir, que quan creem programes aqu\u00ed, nom\u00e9s utilitzaran la configuraci\u00f3 i els paquets d\u2019aquest entorn concret. Nota: a l\u2019entorn virtual, podeu utilitzar l\u2019ordre python en lloc de python3 i pip en lloc de pip3 si ho preferiu. Si utilitzeu Python 3 a la vostra m\u00e0quina fora d\u2019un entorn, haureu d\u2019utilitzar exclusivament les ordres python3 i pip3. Despr\u00e9s de seguir aquests passos, el vostre entorn virtual ja es pot utilitzar. Per a desactivar l'entorn virtual, simplement tanquem la consola o utilitzem l'ordre deactivate . Deapareixer\u00e0 el nom de l'entorn virtual abans del prompt.","title":"Segon pas - Configurem un entorn virtual de desenvolupament"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#modes-dexecucio","text":"Interactiva a trav\u00e9s de l'int\u00e8rpret Bash 1 2 3 4 5 ~$ python3 Python 3 .7.3 ( default, Jul 25 2020 , 13 :03:44 ) [ GCC 8 .3.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Execuci\u00f3 d'un fitxer Python Bash 1 2 ~$ python3 hola_mon.py Hola m\u00f3n Execuci\u00f3 d'un script Bash 1 2 3 4 5 6 7 8 9 hola_mon.py --- #!/usr/bin/env python3 print ( \"Hola m\u00f3n\" ) --- ~$ chmod u+x hola_mon.py ~$ ./hola_mon.py Hola m\u00f3n Des d'un Entorn de Desenvolupament IDE","title":"Modes d'execuci\u00f3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-1","text":"Implementa el \"Hola m\u00f3n!\" i executa-lo de les quatre formes possibles.","title":"Activitat 1"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#paraules-reservades-i-identificadors","text":"","title":"Paraules reservades i identificadors"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#paraules-reservades","text":"No es poden utilitzar coma identificador de variables ni nom de funcions, ja que s'utilitzen per a definir la sintaxi i l'estructura d'un programa. Les paraules reservades s\u00f3n: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Per a obtindre la llista completa des de l'int\u00e8rpret: Python 1 2 >>> import keyword >>> print ( keyword . kwlist )","title":"Paraules reservades"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#identificadors","text":"Per convenci\u00f3, els noms de les variables i funcions han de ser: combinacions de lletres min\u00fascules i n\u00fameros comen\u00e7ar per lletra descriptius (excepte en bucles o se sol utilitzar i i j ) amb paraules separades per gui\u00f3 baix Per exemple: nom_usuari, numero_telefon, cognom1, sumar(), ... Recorda que Python \u00e9s un llenguatge case sensitive . Per tant Var i var no s\u00f3n el mateix identificador.","title":"Identificadors"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#instruccions-i-sagnat","text":"","title":"Instruccions i sagnat"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#instruccions","text":"L'int\u00e8rpret de Python va executant l\u00ednia a l\u00ednia cada instrucci\u00f3. Si volem que una instrucci\u00f3 ocupe diverses l\u00ednies ho hem d'indicar amb el car\u00e0cter \\. Per exemple: Python 1 2 3 4 5 >>> a = 1 + 2 + 3 + \\ ... 4 + 5 + 6 + \\ ... 7 + 8 + 9 >>> print ( a ) 45 La continuaci\u00f3 de l\u00ednia \u00e9s implicita dins de par\u00e8ntesis (), corxets [] i claus {}. Python 1 2 3 colors = [ 'red' , 'blue' , 'green' ] Tamb\u00e9 podem posar diverses sent\u00e8ncies en una l\u00ednia: Python 1 a = 1 ; b = 2 ; c = 3","title":"Instruccions"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#sagnat","text":"La majoria de llenguatges de programaci\u00f3 utilitzen les claus {} per a definir blocs de codi. En canvi, Python utilitza el sagnat (identation). Un bloc de codi (cos d'una funci\u00f3, bucle, etc.) comen\u00e7a amb sagnat i acaba amb la primera l\u00ednia sense sagnat. Dep\u00e8n de vosaltres la quantitat de sagnat, per\u00f2 ha de ser coherent en tot el bloc. Generalment, s\u2019utilitzen quatre espais en blanc per a sagnat i es prefereixen a les tabulacions. El resultat \u00e9s un codi net i clar. Exemple: Python 1 2 3 4 for i in range ( 1 , 11 ): print ( i ) if i == 5 : break Un sagnat incorrecte llan\u00e7a un IndentationError .","title":"Sagnat"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#comentaris","text":"Els comentaris s\u00f3n molt importants en escriure un programa. Descriuen el que passa dins d\u2019un programa, de manera que una persona que mira el codi font no tinga dificultats per entendre'l. A m\u00e9s, \u00e9s possible que oblideu els detalls clau d'implementaci\u00f3 del programa que acabeu d\u2019escriure. Per tant, invertir temps per explicar aquests conceptes en forma de comentaris sempre \u00e9s fruct\u00edfer . A Python, fem servir el s\u00edmbol coixinet (#) per comen\u00e7ar a escriure un comentari. S'est\u00e9n fins al car\u00e0cter de l\u00ednia nova. No cal que el comentari estiga a principi de l\u00ednia, pot estar en mig. Per fer comentaris multil\u00ednia, podem utilitzar el coixinet a principi de cada l\u00ednia. Tamb\u00e9 podem fer servir les cometes dobles o simples tres vegades. Exemple: Python 1 2 ''' Comentari multil\u00ednia'''","title":"Comentaris"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#docstrings","text":"Una docstring \u00e9s una abreviatura de text de documentaci\u00f3. La documentaci\u00f3 de Python s\u00f3n els textos que apareixen just despr\u00e9s de la definici\u00f3 d'una funci\u00f3, m\u00e8tode, classe o m\u00f2dul. S'utilitzen cometes triples durant l'escriptura de la documentaci\u00f3. Per exemple: Python 1 2 3 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num La documentaci\u00f3 s\u2019associa a l\u2019objecte com a atribut doc . Per tant, podem accedir a la documentaci\u00f3 de la funci\u00f3 anterior amb les seg\u00fcents l\u00ednies de codi: Python 1 2 3 4 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num print ( doble . __ doc__ ) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def suma_binaria ( a , b ): ''' Torna la suma de dos enters en binari. Par\u00e0metres: a (int): Un enter b (int): Altre enter Torna: suma_binaria (str): String amb els digits binaris de la suma ''' suma_binaria = bin ( a + b )[ 2 :] return suma_binaria print ( suma_binaria . __doc__ )","title":"Docstrings"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#variables-constants-i-tipus","text":"","title":"Variables, constants i tipus"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#variables","text":"En Python, quan declarem una variable i li assignem un valor, realment estem creant un objecte i assignant un valor per refer\u00e8ncia. Python 1 2 3 4 5 6 >>> num = 10 >>> type ( num ) < class ' int '> >>> num = 10.0 >>> type ( num ) < class ' float '> Podem inicialitzar m\u00faltiples variables en una mateixa l\u00ednia, ja siga amb el mateix valor o diferent. Python 1 2 a , b , c = 5 , 3.2 , \"Hola\" x = y = z = \"iguals\"","title":"Variables"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#constants","text":"A Python no existeixen les constants a l'estil de static final de Java, sin\u00f3 que simplement es defineix una variable que no es modifica el valor. Normalment es definixen en un m\u00f2dul a banda, utilitzant maj\u00fascules i gui\u00f3 baix si \u00e9s necessari, que s'importa a l'arxiu principal. Python 1 2 3 4 5 6 7 8 9 10 constants . py --- PI = 3.14 main . py --- import constants.py radi = 5 perimetre = 2 * constants . PI * radi print ( perimetre )","title":"Constants"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#tipus","text":"L'assignaci\u00f3 de tipus \u00e9s din\u00e0mica i pot canviar, per aix\u00f2 no declarem els tipus de les variables. Per determinar el tipus d'un objecte, fem servir el m\u00e8tode type() . Els tipus d'objecte definits a Python3 s\u00f3n: 1. Num\u00e8rics: 1.1. Integer Python 1 2 3 4 a = 0b1010 #Binary b = 100 #Decimal c = 0o310 #Octal d = 0x12c #Hexadecimal 1.2. Float Python 1 2 float_1 = 10.5 float_2 = 1.5e2 1.3. Complex Python 1 x = 3 + 4 j Strings Python 1 nom = 'Ferran Cunyat' Els principals m\u00e8todes sobre un string s\u00f3n capitalize(), count(), find(), format(), lower(), replace(), split(), title(), translate(), upper() . Boolean Python 1 2 3 4 x = ( 1 == True ) # True pren el valor num\u00e8ric 1, mentre que False el 0 y = ( 1 == False ) a = True + 4 b = False + 10 Especials (None) S'utilitza per no donar-li valor a una variable. Python 1 2 3 >>> x = None >>> type ( x ) < class ' NoneType '> Col\u00b7leccions Llista S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, encara que normalment si que ho s\u00f3n. Es definix amb corxets i els elements separats per comes. Podem accedir a un element o un rang i \u00e9s mutable. Python 1 2 3 4 5 6 >>> a = [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> print ( a ) [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> a [ 3 ] = \"Ferran\" >>> print ( a [: 4 ]) [ 5 , 10 , 15 , 'Ferran' ] Algunes de les principals funcions que podem aplicar sobre llistes s\u00f3n apend(), clear(), copy(), extend(), insert(), remove(), reverse() . Tupla S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, per\u00f2 esta vegada immutable. Python 1 2 3 4 5 >>> tupla = ( 2 , 'hola' ) >>> tupla [ 1 ] = 'clavel' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Rang Seq\u00fc\u00e8ncia immutable de n\u00fameros, generalment utilitzada per a iterar sobre for o generar llistes r\u00e0pidament. Python 1 2 >>> list ( range ( 0 , 30 , 5 )) [ 0 , 5 , 10 , 15 , 20 , 25 ] 3 . Conjunt (Set) Col\u00b7lecci\u00f3 desordenada d'elements \u00fanics. Ja que \u00e9s una llista desordenada, no la podem indexar i per tant accedir als elements segons la seua posici\u00f3. Python 1 2 3 4 5 6 7 8 >>> a = { 2 , 2 , 5 , 5 , 4 , 10 , 1 , 0 } >>> print ( a ) { 0 , 1 , 2 , 4 , 5 , 10 } >>> a [ 1 ] Traceback ( most recent call last ): File \"<string>\" , line 301 , in runcode File \"<interactive input>\" , line 1 , in < module > TypeError : 'set' object does not support indexing Diccionari Diccionari \u00e9s una col\u00b7lecci\u00f3 no ordenada de parells valor-clau. Generalment s\u2019utilitza quan tenim una gran quantitat de dades. Els diccionaris estan optimitzats per recuperar dades. Hem de con\u00e8ixer la clau per recuperar el valor. A Python, els diccionaris es defineixen entre claus {} i cada element \u00e9s un parell que adopta la forma de clau:valor. La clau i el valor poden ser de qualsevol tipus. Python 1 2 3 4 5 6 7 8 9 10 11 >>> d = { 1 : 'valor' , 'clau' : 2 } >>> print ( type ( d )) < class ' dict '> >>> print ( \"d[1] = \" , d [ 1 ]); d [ 1 ] = valor >>> print ( \"d['clau'] = \" , d [ 'clau' ]); d [ 'clau' ] = 2 >>> print ( \"d[2] = \" , d [ 2 ]); Traceback ( most recent call last ): File \"<stdin>\" , line 2 , in < module > KeyError : 2","title":"Tipus"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-2","text":"Fixa't en el seg\u00fcent fragment de codi: Python 1 2 3 4 5 6 7 8 9 >>> s = [ 1 , 2 ] >>> r = s [:] >>> s [ 0 ] = 2 >>> print ( s ) [ 2 , 2 ] >>> print ( r ) ??? >>> print ( s ) ??? Quina ser\u00e0 l'eixida? Per qu\u00e9? Python 1 2 3 4 5 6 >>> r = s >>> s [ 0 ] = 5 >>> print ( r ) ??? >>> print ( s ) ??? I ara? Per qu\u00e9?","title":"Activitat 2"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#conversio-entre-tipus","text":"","title":"Conversi\u00f3 entre tipus"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#conversio-implicita","text":"S\u00f3n conversions que fa el mateix llenguatge autom\u00e0ticament. Per exemple: Python 1 2 3 4 5 6 7 8 9 10 num_int = 123 num_flo = 1.23 num_nou = num_int + num_flo print ( \"num_int \u00e9s de tipus:\" , type ( num_int )) print ( \"num_flo \u00e9s de tipus:\" , type ( num_flo )) print ( \"Valor de num_nou:\" , num_nou ) print ( \"num_nou \u00e9s de tipus:\" , type ( num_nou ))","title":"Conversi\u00f3 impl\u00edcita"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#conversio-explicita","text":"Utilitzem funcions predefinides per a for\u00e7ar la conversi\u00f3 int(), float(), str(), ... .","title":"Conversi\u00f3 expl\u00edcita"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-3","text":"Quin \u00e9s el resultat d'executar el seg\u00fcent fragment de codi? Python 1 2 3 >>> enter = 123 >>> cadena = \"456\" >>> suma = enter + cadena Definix dues variables, una per a fer la suma entera (579) i l'altra per a concatrenar com a text (123456).","title":"Activitat 3"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#entrada-eixida-i-import","text":"","title":"Entrada, eixida i import"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#entrada","text":"Ja hem vist que per a introduir informaci\u00f3 per teclat utilitzem la funci\u00f3 input([prompt]) .","title":"Entrada"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#eixida","text":"Per a imprimir per ella utilitzarem la funci\u00f3 print() . Moltes vegades s'utilitza en combinaci\u00f3 amb la funci\u00f3 format() dels strings. Python 1 2 3 4 5 >>> x = 5 ; y = 10 >>> print ( 'El valor d \\' x \u00e9s {} i el de y \u00e9s {} ' . format ( x , y )) >>> # Fixeu-se que hem escapat el caracter ' El valor d 'x \u00e9s 5 i el de y \u00e9s 10 >>> print ( 'Hola {nom} , {salutacio} ' . format ( salutacio = 'Bon dia' , nom = 'Pau' ))","title":"Eixida"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-4","text":"Implementa el programa \"Hola m\u00f3n\" utilitzant la funci\u00f3 format.","title":"Activitat 4"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#import","text":"Quan volem fer \u00fas del codi d'un altre m\u00f2dul (.py), l'hem d'importar al programa actual amb import . Python 1 2 >>> import math >>> print ( math . pi ) Tamb\u00e9 podem importar sols alguna de les funcions o atributs amb from Python 1 >>> from math import pi En importar un m\u00f2dul, Python analitza diversos llocs definits a sys.path. \u00c9s una llista de les ubicacions on buscar el m\u00f2dul. Python 1 2 3 >>> import sys >>> sys . path [ '' , '/usr/lib/python37.zip' , '/usr/lib/python3.7' , '/usr/lib/python3.7/lib-dynload' , '/home/ferran/.local/lib/python3.7/site-packages' , '/usr/local/lib/python3.7/dist-packages' , '/usr/lib/python3/dist-packages' ] Per a importar d'una altra carpeta, ho fem amb from paquet import modul . Pots posar ubicacions absolutes o relatives. Si volem importar un codi d'una ubicaci\u00f3 que no est\u00e0 al path. Python 1 2 >>> import sys >>> sys . path . append ( '/path/a/la/carpeta' )","title":"Import"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#espai-de-noms-i-ambit-de-variables","text":"","title":"Espai de noms i \u00e0mbit de variables"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#noms","text":"En Python, tot s\u00f3n objectes, incl\u00fas les funcions. Un nom \u00e9s la forma d'accedir als objectes, i amb la funci\u00f3 id() podem veure la seua ubicaci\u00f3 en mem\u00f2ria. Per exemple: Python 1 2 3 4 5 >>> a = 2 >>> print ( 'id(2) =' , id ( 2 )) id ( 2 ) = 9062656 >>> print ( 'id(a) =' , id ( a )) d ( a ) = 9062656","title":"Noms"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-5","text":"Quin creus que ser\u00e0 el resultat a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 >>> a = 2 >>> print ( 'id(a) =' , id ( a )) >>> a = a + 1 >>> print ( 'id(a) =' , id ( a )) >>> print ( 'id(3) =' , id ( 3 )) >>> b = 2 >>> print ( 'id(b) =' , id ( b )) >>> print ( 'id(2) =' , id ( 2 ))","title":"Activitat 5"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#espais-de-noms-namespaces","text":"Els espais de noms a Python, s\u00f3n una col\u00b7lecci\u00f3 de noms. Diferents espais de noms poden coexistir, per\u00f2 estan completament a\u00efllats. Quan iniciem Python, es crea un espai de noms amb totes les funcions que l'int\u00e8rpret reconeix, espai de noms predefinit . Aquesta \u00e9s la ra\u00f3 per la qual funcions integrades com id (), print () etc. sempre estan disponibles per a nosaltres des de qualsevol part del programa. En canvi, cada m\u00f2dul crea el seu propi espai de noms global . Aquests espais de noms estan a\u00efllats entre ells. Per tant, podem donar el mateix nom a objectes de m\u00f2duls diferents sense que entren en conflicte. Els m\u00f2duls poden contindre funcions i classes. Quan es crida una funci\u00f3, es crea un espai de noms local que t\u00e9 noms propis definits. Similar, \u00e9s el cas de la classe. El seg\u00fcent diagrama pot ajudar a aclarir aquest concepte.","title":"Espais de noms (namespaces)"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#ambit-de-les-variables","text":"Tot i que hi ha diversos espais de noms definits, \u00e9s possible que no puguem accedir a tots ells des de totes les parts del programa. El concepte d\u2019\u00e0mbit entra en joc. Sempre hi ha almenys tres \u00e0mbits definits. \u00c0mbit local a la funci\u00f3 amb nom locals \u00c0mbit del m\u00f2dul que t\u00e9 noms globals \u00c0mbit m\u00e9s extern que t\u00e9 noms predefinits Quan es fa una refer\u00e8ncia dins d'una funci\u00f3, el nom es busca a l'espai de noms local, despr\u00e9s a l'espai de noms global i finalment a l'espai de noms predefinit. Si hi ha una funci\u00f3 dins d\u2019una altra funci\u00f3, s\u2019anida un nou \u00e0mbit dins de l'\u00e0mbit local.","title":"\u00c0mbit de les variables"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-6","text":"Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def funcio_externa (): a = 20 def funcio_interna (): a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Activitat 6"},{"location":"unitats/python/teoria/1%20-%20Introducci%C3%B3/#activitat-7","text":"Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def funcio_externa (): global a a = 20 def funcio_interna (): global a a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Activitat 7"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/","text":"Control de fluxe If ... else Python 1 2 3 4 5 6 7 num = int ( input ( \"N\u00famero: \" )) if num > 0 : print ( \"Positiu\" ) elif num == 0 : print ( \"Zero\" ) else : print ( \"Negatiu\" ) For No existeix un for a l'estil de C o Java. Am\u00e9s podem afegir un else al final de bucle. Python 1 2 3 4 5 6 7 8 9 10 nums = [ 6 , 5 , 3 , 8 , 4 , 2 , 5 , 4 , 11 ] suma = 0 for val in nums : suma = suma + val else : print ( \"Hem acabat de sumar\" ) print ( \"La suma \u00e9s\" , suma ) Podem combinar el bucle for amb la funci\u00f3 range(principi, fi, pas) . Activitat 8 Fes una aplicaci\u00f3 que imprimisca els primers 100 n\u00fameros imparells. Activitat 9 Fes una aplicaci\u00f3 que donada la seg\u00fcent llista, imprimisca els seus membres: aficions = ['esports', 'cine', 'teatre'] While Python 1 2 3 4 5 6 7 contador = 0 while contador < 3 : print ( \"Dins del while\" ) contador = contador + 1 else : print ( \"Fora del bucle\" ) Break i continue S'utilitzen igual que a Java. El continue passa a la seg\u00fcent iteraci\u00f3, mentre que el break ix del bucle. En cas de bucles anidats, ix del bucle intern. Switch - Case Fins a la versi\u00f3 3.10, python no implementava el switch-case d'altres llenguatges i s'havia d'utilitzar un bloc d'if-elseif: Python 1 2 3 4 5 6 7 8 9 10 11 12 edat = 120 if age > 90 : print ( \"Esta festa \u00e9s sols per a joves.\" ) elif age < 0 : print ( \"Encara no has nascut!!\" ) elif age >= 18 : print ( \"Endavant!!\" ) else : \"Ers massa jove per entrar a esta festa\" # Output: Esta festa \u00e9s sols per a joves. O definir una funci\u00f3 que executara aquesta funcionalitat: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def switch ( lang ): if lang == \"JavaScript\" : return \"Ser\u00e0s programador web.\" elif lang == \"PHP\" : return \"Ser\u00e0s programador de backend.\" elif lang == \"Python\" : return \"Ser\u00e0s cient\u00edfic de dades.\" elif lang == \"Solidity\" : return \"Ser\u00e0s desenvolupador de Blockchain.\" elif lang == \"Dart\" : return \"Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" print ( switch ( \"JavaScript\" )) print ( switch ( \"Python\" )) print ( switch ( \"Dart\" )) \"\"\" Eixida: Ser\u00e0s programador web. Ser\u00e0s cient\u00edfic de dades. Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils \"\"\" A partir de la versi\u00f3 3.10, Python disposa de les paraules reservades match-case : Python 1 2 3 4 5 6 7 8 9 match terme : case patr\u00f3 - 1 : acci\u00f3 - 1 case patr\u00f3 - 2 : acci\u00f3 - 2 case patr\u00f3 - 3 : acci\u00f3 - 3 case _ : acci\u00f3 - per - defecte Exemple Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lang = input ( \"Quin llenguatge de programaci\u00f3 vols aprendre? \" ) match lang : case \"JavaScript\" : print ( \"Ser\u00e0s programador web.\" ) case \"Python\" : print ( \"Ser\u00e0s cient\u00edfic de dades.\" ) case \"PHP\" : print ( \"Ser\u00e0s programador de backend.\" ) case \"Solidity\" : print ( \"Ser\u00e0s desenvolupador de Blockchain.\" ) case \"Dart\" : print ( \"er\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" ) case _ : print ( \"L'idioma no importa, el que importa \u00e9s resoldre problemes.\" )","title":"Control de fluxe"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#control-de-fluxe","text":"","title":"Control de fluxe"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#if-else","text":"Python 1 2 3 4 5 6 7 num = int ( input ( \"N\u00famero: \" )) if num > 0 : print ( \"Positiu\" ) elif num == 0 : print ( \"Zero\" ) else : print ( \"Negatiu\" )","title":"If ... else"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#for","text":"No existeix un for a l'estil de C o Java. Am\u00e9s podem afegir un else al final de bucle. Python 1 2 3 4 5 6 7 8 9 10 nums = [ 6 , 5 , 3 , 8 , 4 , 2 , 5 , 4 , 11 ] suma = 0 for val in nums : suma = suma + val else : print ( \"Hem acabat de sumar\" ) print ( \"La suma \u00e9s\" , suma ) Podem combinar el bucle for amb la funci\u00f3 range(principi, fi, pas) .","title":"For"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#activitat-8","text":"Fes una aplicaci\u00f3 que imprimisca els primers 100 n\u00fameros imparells.","title":"Activitat 8"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#activitat-9","text":"Fes una aplicaci\u00f3 que donada la seg\u00fcent llista, imprimisca els seus membres: aficions = ['esports', 'cine', 'teatre']","title":"Activitat 9"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#while","text":"Python 1 2 3 4 5 6 7 contador = 0 while contador < 3 : print ( \"Dins del while\" ) contador = contador + 1 else : print ( \"Fora del bucle\" )","title":"While"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#break-i-continue","text":"S'utilitzen igual que a Java. El continue passa a la seg\u00fcent iteraci\u00f3, mentre que el break ix del bucle. En cas de bucles anidats, ix del bucle intern.","title":"Break i continue"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#switch-case","text":"Fins a la versi\u00f3 3.10, python no implementava el switch-case d'altres llenguatges i s'havia d'utilitzar un bloc d'if-elseif: Python 1 2 3 4 5 6 7 8 9 10 11 12 edat = 120 if age > 90 : print ( \"Esta festa \u00e9s sols per a joves.\" ) elif age < 0 : print ( \"Encara no has nascut!!\" ) elif age >= 18 : print ( \"Endavant!!\" ) else : \"Ers massa jove per entrar a esta festa\" # Output: Esta festa \u00e9s sols per a joves. O definir una funci\u00f3 que executara aquesta funcionalitat: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def switch ( lang ): if lang == \"JavaScript\" : return \"Ser\u00e0s programador web.\" elif lang == \"PHP\" : return \"Ser\u00e0s programador de backend.\" elif lang == \"Python\" : return \"Ser\u00e0s cient\u00edfic de dades.\" elif lang == \"Solidity\" : return \"Ser\u00e0s desenvolupador de Blockchain.\" elif lang == \"Dart\" : return \"Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" print ( switch ( \"JavaScript\" )) print ( switch ( \"Python\" )) print ( switch ( \"Dart\" )) \"\"\" Eixida: Ser\u00e0s programador web. Ser\u00e0s cient\u00edfic de dades. Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils \"\"\" A partir de la versi\u00f3 3.10, Python disposa de les paraules reservades match-case : Python 1 2 3 4 5 6 7 8 9 match terme : case patr\u00f3 - 1 : acci\u00f3 - 1 case patr\u00f3 - 2 : acci\u00f3 - 2 case patr\u00f3 - 3 : acci\u00f3 - 3 case _ : acci\u00f3 - per - defecte","title":"Switch - Case"},{"location":"unitats/python/teoria/2%20-%20Control%20de%20fluxe/#exemple","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lang = input ( \"Quin llenguatge de programaci\u00f3 vols aprendre? \" ) match lang : case \"JavaScript\" : print ( \"Ser\u00e0s programador web.\" ) case \"Python\" : print ( \"Ser\u00e0s cient\u00edfic de dades.\" ) case \"PHP\" : print ( \"Ser\u00e0s programador de backend.\" ) case \"Solidity\" : print ( \"Ser\u00e0s desenvolupador de Blockchain.\" ) case \"Dart\" : print ( \"er\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" ) case _ : print ( \"L'idioma no importa, el que importa \u00e9s resoldre problemes.\" )","title":"Exemple"},{"location":"unitats/python/teoria/3%20-%20Funcions/","text":"Funcions Definici\u00f3 de funcions Python 1 2 3 def nom_funcio ( par\u00e0metres ): \"\"\"docstring\"\"\" instruccions ( s ) Nota: Recordeu l\u00e0mbit de les variables, ja que hi haur\u00e0 variables locals a la funci\u00f3. Arguments Valors per defecte Els arguments de les funcions poden tindre un valor per defecte. En cas de no assignar-li un valor per defecte, necessitem fer la crida passant-li el valor de l'argument. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( nom = \"desconegut\" , msg = \"Benvingut!\" ): \"\"\" Funci\u00f3 per saludar a un usuari Entrada: nom=\"desconegut\": String, nom de l'usuari msg=\"Benvingut!\": String, missatge de salutaci\u00f3 Si no li proporcionem valors en la crida, utilitzar\u00e0 els valors per defecte \"\"\" print ( \"Hola\" , nom + '.' , msg ) La crida a la funci\u00f3 la podem fer sense arguments, amb un o amb dos. \u00c9s una forma de fer una sobrec\u00e0rrega de m\u00e8todes de forma molt r\u00e0pida. Python 1 2 3 4 5 saluda ( \"Tom\u00e0s\" , \"Qu\u00e8 fas?\" ) saluda ( \"Pau\" ) saluda () saluda ( msg = \"\" , nom = \"Artur\" ) saluda ( msg = \"\" , \"Artur\" ) Nombre arbitrari d'arguments Si no sabem a priori quants arguments rebr\u00e0 la funci\u00f3, podem utilitzar el car\u00e0cter \"*\" en la definici\u00f3 de la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( * noms ): \"\"\" Funci\u00f3 per saludar a un conjunt d'usuaris Entrada: noms: llistat de noms \"\"\" for nom in noms : print ( \"Hola\" , nom ) saluda ( \"Alex\" , \"Guillem\" , \"Javier\" ) Funcions recursives La recursi\u00f3 \u00e9s el proc\u00e9s de definir alguna cosa en termes d'eixa mateixa cosa. Aleshores, una funci\u00f3 recursiva \u00e9s aquella que es crida a s\u00ed mateix. S'ha d'anar molt en compte en crear correctament la condici\u00f3 d'eixida de la funci\u00f3, ja que d'altra forma entrariem en bucle infinit. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def factorial ( x ): \"\"\"Funci\u00f3 per a calcular el fatorial d'un enter. Entrada: - x: int, el nombre del que volem calcular el factorial Eixida: - x!: int, factorial d'x \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) num = int ( input ( \"N\u00famero: \" )) print ( num , \"! =\" , factorial ( num )) Funcions an\u00f2nimes Les funcions an\u00f2nimes o funcions lambda , s\u00f3n funcions sense nom. Poden tindre un nombre indeterminat d'arguments, per\u00f2 sols una expressi\u00f3, que ser\u00e0 avaluada i retornat el seu resultat. Python 1 2 3 quadrat = lambda x : x ** 2 print ( quadrat ( 5 )) Normalment les funcions lambda s'utilitzen en combinaci\u00f3 amb altres funcions com filter(), map(), etc. La funci\u00f3 map() rep com a arguments una funci\u00f3 i una llista, i torna una llista del mateix tamany on cada element \u00e9s el resultat d'aplicar la funci\u00f3 sobre l'element que ocupa la mateixa posici\u00f3 a la llista original. La funci\u00f3 filter() , rep una funci\u00f3 i una llista com a arguments, i torna com a resultat una llista amb els elements que avaluen a True la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 llista = [ 1 , 5 , 4 , 6 , 8 , 11 , 3 , 12 ] nova_llista = list ( map ( lambda x : x ** 2 , llista )) print ( nova_llista ) \"\"\" Eixida: [1, 25, 16, 36, 64, 121, 9, 144] \"\"\" Activitat 10 Definix una llista i utilitzant filter, que la separe en dues llistes, una amb els elements parells i l'altra amb els senars. Packages Igual que la informaci\u00f3 al disc dur est\u00e0 organitzada en carpetes i subcarpetes, un programa en Python es pot organitzar en paquets, sub paquets i m\u00f2duls. A\u00e7\u00f2 fa un programa m\u00e9s f\u00e0cil de gestionar i conceptualment m\u00e9s clar. Una carpeta ha de contindre un arxiu anomenat __init__.py. Este arxiu pot estar buit o no, per\u00f2 normalment cont\u00e9 codi d'inicialitzaci\u00f3. Per a importar un m\u00f2dul d'un paquet utilitzariem import o from ... import . Python 1 2 import Game.Level.start from Game.Level import start","title":"Funcions"},{"location":"unitats/python/teoria/3%20-%20Funcions/#funcions","text":"","title":"Funcions"},{"location":"unitats/python/teoria/3%20-%20Funcions/#definicio-de-funcions","text":"Python 1 2 3 def nom_funcio ( par\u00e0metres ): \"\"\"docstring\"\"\" instruccions ( s ) Nota: Recordeu l\u00e0mbit de les variables, ja que hi haur\u00e0 variables locals a la funci\u00f3.","title":"Definici\u00f3 de funcions"},{"location":"unitats/python/teoria/3%20-%20Funcions/#arguments","text":"","title":"Arguments"},{"location":"unitats/python/teoria/3%20-%20Funcions/#valors-per-defecte","text":"Els arguments de les funcions poden tindre un valor per defecte. En cas de no assignar-li un valor per defecte, necessitem fer la crida passant-li el valor de l'argument. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( nom = \"desconegut\" , msg = \"Benvingut!\" ): \"\"\" Funci\u00f3 per saludar a un usuari Entrada: nom=\"desconegut\": String, nom de l'usuari msg=\"Benvingut!\": String, missatge de salutaci\u00f3 Si no li proporcionem valors en la crida, utilitzar\u00e0 els valors per defecte \"\"\" print ( \"Hola\" , nom + '.' , msg ) La crida a la funci\u00f3 la podem fer sense arguments, amb un o amb dos. \u00c9s una forma de fer una sobrec\u00e0rrega de m\u00e8todes de forma molt r\u00e0pida. Python 1 2 3 4 5 saluda ( \"Tom\u00e0s\" , \"Qu\u00e8 fas?\" ) saluda ( \"Pau\" ) saluda () saluda ( msg = \"\" , nom = \"Artur\" ) saluda ( msg = \"\" , \"Artur\" )","title":"Valors per defecte"},{"location":"unitats/python/teoria/3%20-%20Funcions/#nombre-arbitrari-darguments","text":"Si no sabem a priori quants arguments rebr\u00e0 la funci\u00f3, podem utilitzar el car\u00e0cter \"*\" en la definici\u00f3 de la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( * noms ): \"\"\" Funci\u00f3 per saludar a un conjunt d'usuaris Entrada: noms: llistat de noms \"\"\" for nom in noms : print ( \"Hola\" , nom ) saluda ( \"Alex\" , \"Guillem\" , \"Javier\" )","title":"Nombre arbitrari d'arguments"},{"location":"unitats/python/teoria/3%20-%20Funcions/#funcions-recursives","text":"La recursi\u00f3 \u00e9s el proc\u00e9s de definir alguna cosa en termes d'eixa mateixa cosa. Aleshores, una funci\u00f3 recursiva \u00e9s aquella que es crida a s\u00ed mateix. S'ha d'anar molt en compte en crear correctament la condici\u00f3 d'eixida de la funci\u00f3, ja que d'altra forma entrariem en bucle infinit. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def factorial ( x ): \"\"\"Funci\u00f3 per a calcular el fatorial d'un enter. Entrada: - x: int, el nombre del que volem calcular el factorial Eixida: - x!: int, factorial d'x \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) num = int ( input ( \"N\u00famero: \" )) print ( num , \"! =\" , factorial ( num ))","title":"Funcions recursives"},{"location":"unitats/python/teoria/3%20-%20Funcions/#funcions-anonimes","text":"Les funcions an\u00f2nimes o funcions lambda , s\u00f3n funcions sense nom. Poden tindre un nombre indeterminat d'arguments, per\u00f2 sols una expressi\u00f3, que ser\u00e0 avaluada i retornat el seu resultat. Python 1 2 3 quadrat = lambda x : x ** 2 print ( quadrat ( 5 )) Normalment les funcions lambda s'utilitzen en combinaci\u00f3 amb altres funcions com filter(), map(), etc. La funci\u00f3 map() rep com a arguments una funci\u00f3 i una llista, i torna una llista del mateix tamany on cada element \u00e9s el resultat d'aplicar la funci\u00f3 sobre l'element que ocupa la mateixa posici\u00f3 a la llista original. La funci\u00f3 filter() , rep una funci\u00f3 i una llista com a arguments, i torna com a resultat una llista amb els elements que avaluen a True la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 llista = [ 1 , 5 , 4 , 6 , 8 , 11 , 3 , 12 ] nova_llista = list ( map ( lambda x : x ** 2 , llista )) print ( nova_llista ) \"\"\" Eixida: [1, 25, 16, 36, 64, 121, 9, 144] \"\"\"","title":"Funcions an\u00f2nimes"},{"location":"unitats/python/teoria/3%20-%20Funcions/#activitat-10","text":"Definix una llista i utilitzant filter, que la separe en dues llistes, una amb els elements parells i l'altra amb els senars.","title":"Activitat 10"},{"location":"unitats/python/teoria/3%20-%20Funcions/#packages","text":"Igual que la informaci\u00f3 al disc dur est\u00e0 organitzada en carpetes i subcarpetes, un programa en Python es pot organitzar en paquets, sub paquets i m\u00f2duls. A\u00e7\u00f2 fa un programa m\u00e9s f\u00e0cil de gestionar i conceptualment m\u00e9s clar. Una carpeta ha de contindre un arxiu anomenat __init__.py. Este arxiu pot estar buit o no, per\u00f2 normalment cont\u00e9 codi d'inicialitzaci\u00f3. Per a importar un m\u00f2dul d'un paquet utilitzariem import o from ... import . Python 1 2 import Game.Level.start from Game.Level import start","title":"Packages"},{"location":"unitats/python/teoria/4%20-%20Fitxers/","text":"Tractament de fitxers Fitxers Entrada eixida utilitzant fitxers Per a llegir o escriure en un fitxer, primer l\u2019hem d\u2019obrir. Quan acabem, s\u2019ha de tancar perqu\u00e8 s\u2019alliberen els recursos relacionats amb el fitxer. Per tant, a Python, utilitzem la seg\u00fcent seq\u00fc\u00e8ncia d'operacions per traballar amb fitxers: Obrir un fitxer Llegir o escriure Tancar el fitxer Open Per obrir un fitxer utilitzem la funci\u00f3 open() . Python 1 2 >>> f = open ( \"test.txt\" ) # arxiu en el mateix directori >>> f = open ( \"C:/Python38/README.txt\" ) # path sencer A m\u00e9s, podem especificar el mode d'apertura i la codificaci\u00f3. Mode Descripci\u00f3 r lectura w escriptura x creaci\u00f3 exclusiva (falla si ja existeix) a afegir al final, el crea si no existeix t mode lectura de text (per defecte) b mode binari + actualitzaci\u00f3 (lectura i escriptura ) Python 1 2 >>> f = open ( \"test.txt\" , 'w' ) # obert per a escriptura >>> f = open ( \"test.txt\" , mode = 'r' , encoding = 'utf-8' ) Warning \u00c9s important que tingau en compte que quan l'int\u00e8rpret de python s'executa, ho fa des del directori del qu\u00e8 s'ha llan\u00e7at(el podeu obtindre mitjan\u00e7ant os.getcwd() ), per aix\u00f2 la c\u00e0rrega de fitxers en rutes relatives en funcions tipus open , load , etc potser vos d\u00f3ne un error indicant que no el troba. f = open(\"ruta relativa/arxiu.txt\") S'han d'evitar les rutes absolutes . El que podeu fer per evitar estos errors \u00e9s obtindre la ruta des del fitxer font de la seg\u00fcent forma: Python 1 2 3 ruta_base = os . path . dirname ( __file__ ) ruta_a_recurs = os . path . join ( ruta_base , \"arxiu.txt\" ) f = open ( ruta_a_recurs ) Close Python utilitza un garbage collector per netejar objectes sense refer\u00e8ncies, per\u00f2 no hem de confiar per tancar el fitxer. Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions sobre l'arxiu finally : f . close () Altra possibilitat \u00e9s amb with . En este cas no hem de tancar-lo expl\u00edcitament. Python 1 2 with open ( \"test.txt\" , encoding = 'utf-8' ) as f : # operacions sobre l'arxiu Escriptura Per a escriure, necessitem haver-lo obert amb les opcions w, a o x. Compte amb l'opci\u00f3 w, perqu\u00e8 sobreescriu els arxius. Python 1 2 3 4 with open ( \"test.txt\" , 'w' , encoding = 'utf-8' ) as f : f . write ( \"Primer arxiu \\n \" ) f . write ( \"Este arxiu \\n \" ) f . write ( \"cont\u00e9 tres l\u00ednies \\n \" ) Lectura Utilitzarem el m\u00e8tode read() per a llegir. La funci\u00f3 tell() ens diu en quina posici\u00f3 tenim el cursor i amb seek() el podem modificar. Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> f = open ( \"test.txt\" , 'r' , encoding = 'utf-8' ) >>> f . read ( 6 ) 'Primer' >>> f . read ( 6 ) ' arxiu' >>> f . read () # llig fins al final ' \\n Este arxiu \\n cont\u00e9 tres l\u00ednies \\n ' >>> f . read () # posteriors lectures tornen la cadena buida '' Python 1 2 3 4 5 6 7 8 9 10 >>> f . tell () 45 >>> f . seek ( 0 ) 0 >>> print ( f . read ()) Primer arxiu Este arxiu cont\u00e9 tres l\u00ednies Tamb\u00e9 podem utilitzar la funci\u00f3 readline() per a llegir una l\u00ednia, o readlines() per a que ens torne una llista de l\u00ednies llegides. Activitat 11 Crea una aplicaci\u00f3 que vaja llegint operacions d'un fitxer \"operacions.txt\" que contindr\u00e0 una operaci\u00f3 per l\u00ednia. Per exemple: 4 + 4 Haur\u00e0 de guardar els resultats en un altre arxiu \"resultats.txt\". Per exemple: 4 + 4 = 8 Utilitza funcions an\u00f2nimes per a implementar les operacions de suma, resta, multiplicaci\u00f3 i divisi\u00f3, que seran les \u00faniques operacions reconegudes per la nostra aplicaci\u00f3. Directoris Si hi ha una gran quantitat de fitxers i directoris amb els que tractar, disposem del m\u00f2dul os (operating system), que ens proporciona m\u00e8todes per al seu tractament. Per a veure el directori de treball, utilitzem getcwd() . Python 1 2 3 >>> import os >>> os . getcwd () Per a canviar de directori, chdir() . Python 1 >>> os . chdir ( '/home/ferran' ) Per a llistar els directoris ens servim de listdir() . Python 1 >>> os . listdir ( '/home' ) Per crear un directori usem mkdir() . Python 1 >>> os . mkdir ( 'Nova_carpeta' ) Si volem renombrar un directori. Python 1 >>> os . rename ( 'Nova_carpeta' , 'Vella_carpeta' ) Per a eliminar un arxiu utilitzarem remove() . Si el que volem eliminar \u00e9s una carpeta buida rmdir() . Python 1 2 >>> os . remove ( 'arxiu.txt' ) >>> os . rmdir ( 'Vella_carpeta' ) En el cas que la carpeta no estiga buida, hem d'importar el m\u00f2dul shutil i utilitzar la funci\u00f3 rmtree() . Python 1 2 >>> import shutil >>> shutil . rmtree ( 'Carpeta' )","title":"Tractament de fitxers"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#tractament-de-fitxers","text":"","title":"Tractament de fitxers"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#fitxers","text":"","title":"Fitxers"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#entrada-eixida-utilitzant-fitxers","text":"Per a llegir o escriure en un fitxer, primer l\u2019hem d\u2019obrir. Quan acabem, s\u2019ha de tancar perqu\u00e8 s\u2019alliberen els recursos relacionats amb el fitxer. Per tant, a Python, utilitzem la seg\u00fcent seq\u00fc\u00e8ncia d'operacions per traballar amb fitxers: Obrir un fitxer Llegir o escriure Tancar el fitxer","title":"Entrada eixida utilitzant fitxers"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#open","text":"Per obrir un fitxer utilitzem la funci\u00f3 open() . Python 1 2 >>> f = open ( \"test.txt\" ) # arxiu en el mateix directori >>> f = open ( \"C:/Python38/README.txt\" ) # path sencer A m\u00e9s, podem especificar el mode d'apertura i la codificaci\u00f3. Mode Descripci\u00f3 r lectura w escriptura x creaci\u00f3 exclusiva (falla si ja existeix) a afegir al final, el crea si no existeix t mode lectura de text (per defecte) b mode binari + actualitzaci\u00f3 (lectura i escriptura ) Python 1 2 >>> f = open ( \"test.txt\" , 'w' ) # obert per a escriptura >>> f = open ( \"test.txt\" , mode = 'r' , encoding = 'utf-8' ) Warning \u00c9s important que tingau en compte que quan l'int\u00e8rpret de python s'executa, ho fa des del directori del qu\u00e8 s'ha llan\u00e7at(el podeu obtindre mitjan\u00e7ant os.getcwd() ), per aix\u00f2 la c\u00e0rrega de fitxers en rutes relatives en funcions tipus open , load , etc potser vos d\u00f3ne un error indicant que no el troba. f = open(\"ruta relativa/arxiu.txt\") S'han d'evitar les rutes absolutes . El que podeu fer per evitar estos errors \u00e9s obtindre la ruta des del fitxer font de la seg\u00fcent forma: Python 1 2 3 ruta_base = os . path . dirname ( __file__ ) ruta_a_recurs = os . path . join ( ruta_base , \"arxiu.txt\" ) f = open ( ruta_a_recurs )","title":"Open"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#close","text":"Python utilitza un garbage collector per netejar objectes sense refer\u00e8ncies, per\u00f2 no hem de confiar per tancar el fitxer. Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions sobre l'arxiu finally : f . close () Altra possibilitat \u00e9s amb with . En este cas no hem de tancar-lo expl\u00edcitament. Python 1 2 with open ( \"test.txt\" , encoding = 'utf-8' ) as f : # operacions sobre l'arxiu","title":"Close"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#escriptura","text":"Per a escriure, necessitem haver-lo obert amb les opcions w, a o x. Compte amb l'opci\u00f3 w, perqu\u00e8 sobreescriu els arxius. Python 1 2 3 4 with open ( \"test.txt\" , 'w' , encoding = 'utf-8' ) as f : f . write ( \"Primer arxiu \\n \" ) f . write ( \"Este arxiu \\n \" ) f . write ( \"cont\u00e9 tres l\u00ednies \\n \" )","title":"Escriptura"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#lectura","text":"Utilitzarem el m\u00e8tode read() per a llegir. La funci\u00f3 tell() ens diu en quina posici\u00f3 tenim el cursor i amb seek() el podem modificar. Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> f = open ( \"test.txt\" , 'r' , encoding = 'utf-8' ) >>> f . read ( 6 ) 'Primer' >>> f . read ( 6 ) ' arxiu' >>> f . read () # llig fins al final ' \\n Este arxiu \\n cont\u00e9 tres l\u00ednies \\n ' >>> f . read () # posteriors lectures tornen la cadena buida '' Python 1 2 3 4 5 6 7 8 9 10 >>> f . tell () 45 >>> f . seek ( 0 ) 0 >>> print ( f . read ()) Primer arxiu Este arxiu cont\u00e9 tres l\u00ednies Tamb\u00e9 podem utilitzar la funci\u00f3 readline() per a llegir una l\u00ednia, o readlines() per a que ens torne una llista de l\u00ednies llegides.","title":"Lectura"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#activitat-11","text":"Crea una aplicaci\u00f3 que vaja llegint operacions d'un fitxer \"operacions.txt\" que contindr\u00e0 una operaci\u00f3 per l\u00ednia. Per exemple: 4 + 4 Haur\u00e0 de guardar els resultats en un altre arxiu \"resultats.txt\". Per exemple: 4 + 4 = 8 Utilitza funcions an\u00f2nimes per a implementar les operacions de suma, resta, multiplicaci\u00f3 i divisi\u00f3, que seran les \u00faniques operacions reconegudes per la nostra aplicaci\u00f3.","title":"Activitat 11"},{"location":"unitats/python/teoria/4%20-%20Fitxers/#directoris","text":"Si hi ha una gran quantitat de fitxers i directoris amb els que tractar, disposem del m\u00f2dul os (operating system), que ens proporciona m\u00e8todes per al seu tractament. Per a veure el directori de treball, utilitzem getcwd() . Python 1 2 3 >>> import os >>> os . getcwd () Per a canviar de directori, chdir() . Python 1 >>> os . chdir ( '/home/ferran' ) Per a llistar els directoris ens servim de listdir() . Python 1 >>> os . listdir ( '/home' ) Per crear un directori usem mkdir() . Python 1 >>> os . mkdir ( 'Nova_carpeta' ) Si volem renombrar un directori. Python 1 >>> os . rename ( 'Nova_carpeta' , 'Vella_carpeta' ) Per a eliminar un arxiu utilitzarem remove() . Si el que volem eliminar \u00e9s una carpeta buida rmdir() . Python 1 2 >>> os . remove ( 'arxiu.txt' ) >>> os . rmdir ( 'Vella_carpeta' ) En el cas que la carpeta no estiga buida, hem d'importar el m\u00f2dul shutil i utilitzar la funci\u00f3 rmtree() . Python 1 2 >>> import shutil >>> shutil . rmtree ( 'Carpeta' )","title":"Directoris"},{"location":"unitats/python/teoria/5%20-%20Excepcions/","text":"Errors i excepcions Podem cometre errors mentre programem. Estos errors es poden classificar b\u00e0sicament en dos tipus: Errors de sintaxi Errors en la l\u00f2gica (Excepcions) Els erros de sintaxi es produixen abans de l'execuci\u00f3, mentre que els erros l\u00f2gics es produixen en temps d'execuci\u00f3. Excepcions Algun exemple d'excepci\u00f3 s\u00f3n els seg\u00fcents: Quan intentem obrir un fitxer (per llegir) que no existeix (FileNotFoundError) Quan intentem dividir un nombre per zero (ZeroDivisionError) Quan intentem importar un m\u00f2dul que no existeix (ImportError). Sempre que es produeixen aquests tipus d\u2019errors d\u2019execuci\u00f3, Python crea un objecte d\u2019excepci\u00f3. Si no el tractem, interrumpeix l'execuci\u00f3 i imprimeix una tra\u00e7a de l'error juntament amb alguns detalls sobre per qu\u00e8 ha produ\u00eft aquest error. Excepcions definides en Python Per a consultar totes les excepcions definides podem utilitzar: Python 1 >>> print ( dir ( locals ()[ '__builtins__' ])) ArithmeticError AssertionError AttributeError BaseException BlockingIOError BrokenPipeError BufferError ChildProcessError ConnectionAbortedError ConnectionError ConnectionRefusedError ConnectionResetError EOFError EnvironmentError Exception FileExistsError FileNotFoundError FloatingPointError GeneratorExit IOError ImportError IndentationError IndexError InterruptedError IsADirectoryError KeyError LookupError MemoryError ModuleNotFoundError NameError NotADirectoryError NotImplementedError OSError OverflowError PermissionError ProcessLookupError RecursionError ReferenceError RuntimeError StopAsyncIteration SyntaxError SystemError TabError TimeoutError TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError ValueError Com funcionen les excepcions Python llan\u00e7a una d'aquestes excepcions en executar una instrucci\u00f3 que provoca un error. Quan es produeixen aquestes excepcions, l'int\u00e8rpret de Python det\u00e9n l'execuci\u00f3 del proc\u00e9s actual i el passa al proc\u00e9s que ha fet la crida, fins que alg\u00fa la tracte. Si ning\u00fan proc\u00e9s la tracta, el programa es detendr\u00e0. Per exemple, considerem un programa en qu\u00e8 tenim una funci\u00f3 A que crida a la funci\u00f3 B, que al seu torn crida a la funci\u00f3 C. Si es produeix una excepci\u00f3 a la funci\u00f3 C per\u00f2 no es tracta a C, l\u2019excepci\u00f3 passa a B i despr\u00e9s a A. Si no es gestiona mai, es mostrar\u00e0 un missatge d'error i el nostre programa s'aturar\u00e0 de sobte. Capturant excepcions en Python A Python, les excepcions es poden gestionar mitjan\u00e7ant una sent\u00e8ncia try. L'operaci\u00f3 cr\u00edtica que pot generar una excepci\u00f3 es col\u00b7loca dins de la cl\u00e0usula try . El codi que gestiona les excepcions s\u2019escriu a la cl\u00e0usula except i s'executar\u00e0 en produ\u00efr-se. Per tant, podem escollir quines operacions es realitzaran una vegada que haguem capturat l'excepci\u00f3. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except : print ( \"Oops! Excepci\u00f3 capturada -->\" , sys . exc_info ()[ 0 ]) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) Com totes les excepcions hereden de la superclasse Exception, podem reescriure el programa com: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except Exception as e : print ( \"Oops! Excepci\u00f3 capturada -->\" , e . __class__ ) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) A l'exemple anterior, no hem utilitzat cap excepci\u00f3 espec\u00edfica a la cl\u00e0usula except. No \u00e9s una bona pr\u00e0ctica de programaci\u00f3, ja que capturar\u00e0 totes les excepcions i gestionar\u00e0 tots els casos de la mateixa manera. Podem especificar quines excepcions hauria de capturar una cl\u00e0usula except. Una cl\u00e0usula try pot tindre un nombre indeterminat de cl\u00e0usules except per gestionar diferents excepcions, per\u00f2, nom\u00e9s s'executar\u00e0 una en cas que es produeixi una excepci\u00f3. Podem utilitzar una tupla de valors per especificar diverses excepcions en una cl\u00e0usula except. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 try : # fer alguna cosa pass except ValueError : # manegem ValueError pass except ( TypeError , ZeroDivisionError ): # manegem m\u00faltiples excepcions # TypeError i ZeroDivisionError pass except : # manegem totes les altres excepcions pass Try ... except ... finally La sent\u00e8ncia try de Python pot tindre una cl\u00e0usula final opcional. Aquesta cl\u00e0usula s\u2019executa independentment de si es produix una excepci\u00f3 o no i s\u2019utilitza generalment per alliberar recursos. Per exemple, podem estar connectats a un centre de dades remot a trav\u00e9s de la xarxa o treballar amb un fitxer o una interf\u00edcie gr\u00e0fica d'usuari (GUI). En totes aquestes circumst\u00e0ncies, hem de netejar recursos abans que el programa ature la seua execuci\u00f3, tant si ho fa de forma controlada com si es para bruscament. Aquestes accions (tancar un fitxer, GUI o desconnectar de la xarxa) es realitzen normalment a la cl\u00e0usula final. Exemple: Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions amb el fitxer finally : f . close () Llan\u00e7ant excepcions en Python Les excepcions es generen normalment quan es produeixen errors en temps d'execuci\u00f3, per\u00f2 tamb\u00e9 podem generar/llan\u00e7ar excepcions manualment mitjan\u00e7ant la paraula reservada raise . Opcionalment, podem passar arguments a l\u2019excepci\u00f3 per aclarir per qu\u00e8 s\u2019ha generat aquesta excepci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 import sys try : nombre = int ( input ( \"Dona'm un n\u00famero positiu: \" )) if nombre <= 0 : raise ValueError ( str ( nombre ) + \" no \u00e9s un n\u00famero positiu!\" ) 1 / 0 except ValueError as ve : print ( \"Excepci\u00f3 capturada:\" , ve ) except : print ( \"Unexpected error:\" , sys . exc_info ()[ 0 ]) raise Assert Amb la paraula reservada assert llancem una excepci\u00f3 sempre i quan l'expressi\u00f3 que la segueix s'avalua a Fals . Si s'avalua a True , es continua l'execuci\u00f3 del programa de forma seq\u00fcencial. Python 1 2 3 4 5 6 7 8 9 try : num = int ( input ( \"Introdueix un nombre positiu: \" )) assert num > 0 except AssertionError : print ( \"AssertionError: No \u00e9s positiu!\" ) except ValueError : print ( \"ValueError: No has introd\u00eft un n\u00famero!\" ) else : print ( \"\u00c9s positiu\" ) Excepcions definides per l'usuari De vegades necessitem definir excepcions que no estan disponibles a Python quan es d\u00f3na alguna condici\u00f3. En este cas, hem de crear les nostres propies excepcions. Per a fer-ho, hem de definir noves classes que hereden de Exception , ja siga directa o indirectament. Esta nova excepci\u00f3 que hem creat tamb\u00e9 podr\u00e0 ser llan\u00e7ada amb raise . Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> class CustomError ( Exception ): ... pass >>> raise CustomError Traceback ( most recent call last ): ... __main__ . CustomError >>> raise CustomError ( \"S'ha produ\u00eft un error\" ) Traceback ( most recent call last ): ... __main__ . CustomError : S 'ha produ\u00eft un error Quan estem desenvolupant un programa gran, \u00e9s una bona pr\u00e0ctica col\u00b7locar totes les excepcions definides per l'usuari que el nostre programa definix en un fitxer separat exceptions.py o errors.py . Activitat 12 Modifica el codi de l'activitat 11 per a que no es produ\u00efsquen errors en l'execuci\u00f3, ja siga per introd\u00efur valor no definits per a les funcions, valors que no s\u00f3n num\u00e8rics o operacions desconegudes. Controla tamb\u00e9 que no es produ\u00efsquen errors en la lectura/escriptura dels arxius. Activitat 13 Anem a implementar un xicotet joc per consola. El programa generar\u00e0 un n\u00famero aleatori entre 0 i 100 (utilitzeu randint() del m\u00f2dul random) i demanar\u00e0 a l'usuari que introdu\u00efsca un n\u00famero. Mentre el n\u00famero siga massa menut, llan\u00e7ar\u00e0 una excepci\u00f3 ErrorEnterMassaMenut indicant-li-ho. Si per contra \u00e9s massa gran llan\u00e7ar\u00e0 ErrorEnterMassaGran. Si s'introdueix un valor no num\u00e8ric, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus ErrorNoEsEnter. El joc acabar\u00e0 quan s'introdu\u00efsca l'enter buscat, felicitant a l'usuari.","title":"Errors i excepcions"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#errors-i-excepcions","text":"Podem cometre errors mentre programem. Estos errors es poden classificar b\u00e0sicament en dos tipus: Errors de sintaxi Errors en la l\u00f2gica (Excepcions) Els erros de sintaxi es produixen abans de l'execuci\u00f3, mentre que els erros l\u00f2gics es produixen en temps d'execuci\u00f3.","title":"Errors i excepcions"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#excepcions","text":"Algun exemple d'excepci\u00f3 s\u00f3n els seg\u00fcents: Quan intentem obrir un fitxer (per llegir) que no existeix (FileNotFoundError) Quan intentem dividir un nombre per zero (ZeroDivisionError) Quan intentem importar un m\u00f2dul que no existeix (ImportError). Sempre que es produeixen aquests tipus d\u2019errors d\u2019execuci\u00f3, Python crea un objecte d\u2019excepci\u00f3. Si no el tractem, interrumpeix l'execuci\u00f3 i imprimeix una tra\u00e7a de l'error juntament amb alguns detalls sobre per qu\u00e8 ha produ\u00eft aquest error.","title":"Excepcions"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#excepcions-definides-en-python","text":"Per a consultar totes les excepcions definides podem utilitzar: Python 1 >>> print ( dir ( locals ()[ '__builtins__' ])) ArithmeticError AssertionError AttributeError BaseException BlockingIOError BrokenPipeError BufferError ChildProcessError ConnectionAbortedError ConnectionError ConnectionRefusedError ConnectionResetError EOFError EnvironmentError Exception FileExistsError FileNotFoundError FloatingPointError GeneratorExit IOError ImportError IndentationError IndexError InterruptedError IsADirectoryError KeyError LookupError MemoryError ModuleNotFoundError NameError NotADirectoryError NotImplementedError OSError OverflowError PermissionError ProcessLookupError RecursionError ReferenceError RuntimeError StopAsyncIteration SyntaxError SystemError TabError TimeoutError TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError ValueError","title":"Excepcions definides en Python"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#com-funcionen-les-excepcions","text":"Python llan\u00e7a una d'aquestes excepcions en executar una instrucci\u00f3 que provoca un error. Quan es produeixen aquestes excepcions, l'int\u00e8rpret de Python det\u00e9n l'execuci\u00f3 del proc\u00e9s actual i el passa al proc\u00e9s que ha fet la crida, fins que alg\u00fa la tracte. Si ning\u00fan proc\u00e9s la tracta, el programa es detendr\u00e0. Per exemple, considerem un programa en qu\u00e8 tenim una funci\u00f3 A que crida a la funci\u00f3 B, que al seu torn crida a la funci\u00f3 C. Si es produeix una excepci\u00f3 a la funci\u00f3 C per\u00f2 no es tracta a C, l\u2019excepci\u00f3 passa a B i despr\u00e9s a A. Si no es gestiona mai, es mostrar\u00e0 un missatge d'error i el nostre programa s'aturar\u00e0 de sobte.","title":"Com funcionen les excepcions"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#capturant-excepcions-en-python","text":"A Python, les excepcions es poden gestionar mitjan\u00e7ant una sent\u00e8ncia try. L'operaci\u00f3 cr\u00edtica que pot generar una excepci\u00f3 es col\u00b7loca dins de la cl\u00e0usula try . El codi que gestiona les excepcions s\u2019escriu a la cl\u00e0usula except i s'executar\u00e0 en produ\u00efr-se. Per tant, podem escollir quines operacions es realitzaran una vegada que haguem capturat l'excepci\u00f3. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except : print ( \"Oops! Excepci\u00f3 capturada -->\" , sys . exc_info ()[ 0 ]) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) Com totes les excepcions hereden de la superclasse Exception, podem reescriure el programa com: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except Exception as e : print ( \"Oops! Excepci\u00f3 capturada -->\" , e . __class__ ) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) A l'exemple anterior, no hem utilitzat cap excepci\u00f3 espec\u00edfica a la cl\u00e0usula except. No \u00e9s una bona pr\u00e0ctica de programaci\u00f3, ja que capturar\u00e0 totes les excepcions i gestionar\u00e0 tots els casos de la mateixa manera. Podem especificar quines excepcions hauria de capturar una cl\u00e0usula except. Una cl\u00e0usula try pot tindre un nombre indeterminat de cl\u00e0usules except per gestionar diferents excepcions, per\u00f2, nom\u00e9s s'executar\u00e0 una en cas que es produeixi una excepci\u00f3. Podem utilitzar una tupla de valors per especificar diverses excepcions en una cl\u00e0usula except. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 try : # fer alguna cosa pass except ValueError : # manegem ValueError pass except ( TypeError , ZeroDivisionError ): # manegem m\u00faltiples excepcions # TypeError i ZeroDivisionError pass except : # manegem totes les altres excepcions pass","title":"Capturant excepcions en Python"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#try-except-finally","text":"La sent\u00e8ncia try de Python pot tindre una cl\u00e0usula final opcional. Aquesta cl\u00e0usula s\u2019executa independentment de si es produix una excepci\u00f3 o no i s\u2019utilitza generalment per alliberar recursos. Per exemple, podem estar connectats a un centre de dades remot a trav\u00e9s de la xarxa o treballar amb un fitxer o una interf\u00edcie gr\u00e0fica d'usuari (GUI). En totes aquestes circumst\u00e0ncies, hem de netejar recursos abans que el programa ature la seua execuci\u00f3, tant si ho fa de forma controlada com si es para bruscament. Aquestes accions (tancar un fitxer, GUI o desconnectar de la xarxa) es realitzen normalment a la cl\u00e0usula final. Exemple: Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions amb el fitxer finally : f . close ()","title":"Try ... except ... finally"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#llancant-excepcions-en-python","text":"Les excepcions es generen normalment quan es produeixen errors en temps d'execuci\u00f3, per\u00f2 tamb\u00e9 podem generar/llan\u00e7ar excepcions manualment mitjan\u00e7ant la paraula reservada raise . Opcionalment, podem passar arguments a l\u2019excepci\u00f3 per aclarir per qu\u00e8 s\u2019ha generat aquesta excepci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 import sys try : nombre = int ( input ( \"Dona'm un n\u00famero positiu: \" )) if nombre <= 0 : raise ValueError ( str ( nombre ) + \" no \u00e9s un n\u00famero positiu!\" ) 1 / 0 except ValueError as ve : print ( \"Excepci\u00f3 capturada:\" , ve ) except : print ( \"Unexpected error:\" , sys . exc_info ()[ 0 ]) raise","title":"Llan\u00e7ant excepcions en Python"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#assert","text":"Amb la paraula reservada assert llancem una excepci\u00f3 sempre i quan l'expressi\u00f3 que la segueix s'avalua a Fals . Si s'avalua a True , es continua l'execuci\u00f3 del programa de forma seq\u00fcencial. Python 1 2 3 4 5 6 7 8 9 try : num = int ( input ( \"Introdueix un nombre positiu: \" )) assert num > 0 except AssertionError : print ( \"AssertionError: No \u00e9s positiu!\" ) except ValueError : print ( \"ValueError: No has introd\u00eft un n\u00famero!\" ) else : print ( \"\u00c9s positiu\" )","title":"Assert"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#excepcions-definides-per-lusuari","text":"De vegades necessitem definir excepcions que no estan disponibles a Python quan es d\u00f3na alguna condici\u00f3. En este cas, hem de crear les nostres propies excepcions. Per a fer-ho, hem de definir noves classes que hereden de Exception , ja siga directa o indirectament. Esta nova excepci\u00f3 que hem creat tamb\u00e9 podr\u00e0 ser llan\u00e7ada amb raise . Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> class CustomError ( Exception ): ... pass >>> raise CustomError Traceback ( most recent call last ): ... __main__ . CustomError >>> raise CustomError ( \"S'ha produ\u00eft un error\" ) Traceback ( most recent call last ): ... __main__ . CustomError : S 'ha produ\u00eft un error Quan estem desenvolupant un programa gran, \u00e9s una bona pr\u00e0ctica col\u00b7locar totes les excepcions definides per l'usuari que el nostre programa definix en un fitxer separat exceptions.py o errors.py .","title":"Excepcions definides per l'usuari"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#activitat-12","text":"Modifica el codi de l'activitat 11 per a que no es produ\u00efsquen errors en l'execuci\u00f3, ja siga per introd\u00efur valor no definits per a les funcions, valors que no s\u00f3n num\u00e8rics o operacions desconegudes. Controla tamb\u00e9 que no es produ\u00efsquen errors en la lectura/escriptura dels arxius.","title":"Activitat 12"},{"location":"unitats/python/teoria/5%20-%20Excepcions/#activitat-13","text":"Anem a implementar un xicotet joc per consola. El programa generar\u00e0 un n\u00famero aleatori entre 0 i 100 (utilitzeu randint() del m\u00f2dul random) i demanar\u00e0 a l'usuari que introdu\u00efsca un n\u00famero. Mentre el n\u00famero siga massa menut, llan\u00e7ar\u00e0 una excepci\u00f3 ErrorEnterMassaMenut indicant-li-ho. Si per contra \u00e9s massa gran llan\u00e7ar\u00e0 ErrorEnterMassaGran. Si s'introdueix un valor no num\u00e8ric, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus ErrorNoEsEnter. El joc acabar\u00e0 quan s'introdu\u00efsca l'enter buscat, felicitant a l'usuari.","title":"Activitat 13"},{"location":"unitats/python/teoria/6%20-%20POO/","text":"Programaci\u00f3 orientada a objectes amb Python \u00c9s un dels paradigmes m\u00e9s populars per resoldre problemes a trav\u00e9s de la programaci\u00f3. Un objecte t\u00e9 dues caracter\u00edstiques: atributs (estat) funcions (comportament) Per exemple: Una persona pot ser un objecte, ja que t\u00e9 les propietats seg\u00fcents: nom, edat com a atributs cantar, ballar com a comportament El concepte de POO a Python se centra en la reutilitzaci\u00f3 de codi. Aquest concepte tamb\u00e9 es coneix com DRY (Don't Repeat Yourself). Classes Una classe \u00e9s una definici\u00f3 d'un objecte abstracte, que representa algun ent de la realitat al nostre programa. Cont\u00e9 tots els detalls comuns sobre tots els objectes del mateix tipus. L'exemple de classe de lloro pot ser: Python 1 2 class Parrot (): pass Ac\u00ed fem servir la paraula clau class per definir una classe Loro buida. Objectes Quan es defineix la classe, nom\u00e9s es defineix la descripci\u00f3 de l'objecte. Per tant, no s\u2019assignen recursos per a la seua execuci\u00f3, ni s'assignen valors als seus atributs. Quan este fet es produeix, aleshores tenim un objecte en mem\u00f2ria sobre el que podem actuar. L'exemple d'objecte de classe lloro pot ser: Python 1 obj = Loro () Aqu\u00ed, obj \u00e9s un objecte de la classe Loro. Suposem que tenim detalls de lloros. Ara, podem construir la classe i crear un objecte per a cada lloro. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Parrot : # class attribute species = \"bird\" # instance attribute def __init__ ( self , name , age ): self . name = name self . age = age # instantiate the Parrot class blu = Parrot ( \"Blu\" , 10 ) woo = Parrot ( \"Woo\" , 15 ) # access the class attributes print ( \"Blu is a {} \" . format ( blu . __class__ . species )) print ( \"Woo is also a {} \" . format ( woo . __class__ . species )) # access the instance attributes print ( \" {} is {} years old\" . format ( blu . name , blu . age )) print ( \" {} is {} years old\" . format ( woo . name , woo . age )) --- Eixida Blu is a bird Woo is also a bird Blu is 10 years old Woo is 15 years old Al programa anterior, hem creat una classe Parrot. A continuaci\u00f3, hem definit uns atributs, que prendran valors diferents en la instanciaci\u00f3 d'objectes diferents. Aquests atributs es defineixen dins del m\u00e8tode init de la classe, que \u00e9s el m\u00e8tode inicialitzador que s\u2019executar\u00e0 nom\u00e9s creem objectes. Despr\u00e9s, creem inst\u00e0ncies de la classe Parrot. blu i woo s\u00f3n refer\u00e8ncies (valor) als nostres objectes nous. Podem accedir als atributs de classe mitjan\u00e7ant __class__.species . Els atributs de classe s\u00f3n els mateixos per a totes les inst\u00e0ncies d\u2019una classe. De la mateixa manera, accedim als atributs de la inst\u00e0ncia mitjan\u00e7ant objecte.nom_atribut . Els atributs d\u2019inst\u00e0ncia (valors) s\u00f3n diferents per a cada inst\u00e0ncia d\u2019una classe. M\u00e8todes S\u00f3n funcions definides dins el cos d'una classe. S'utilitzen per a definir el comportament de l'objecte. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parrot : # instance attributes def __init__ ( self , name , age ): self . name = name self . age = age # instance method def sing ( self , song ): return \" {} sings {} \" . format ( self . name , song ) def dance ( self ): return \" {} is now dancing\" . format ( self . name ) # instantiate the object blu = Parrot ( \"Blu\" , 10 ) # call our instance methods print ( blu . sing ( \"'Happy'\" )) print ( blu . dance ()) --- Blu sings 'Happy' Blu is now dancing Hem definit dos m\u00e8todes sing() i dance(), que s\u00f3n m\u00e8todes d'inst\u00e0ncia, ja que es criden sobre un objecte. Her\u00e8ncia L'her\u00e8ncia \u00e9s una forma de reutilitzar codi sense tindre-lo que reescriure. A\u00e7\u00f2 facilita el manteniment de les aplicacions. Les noves classes s'anomenen classes derivades (o classe filla). La classes de les que deriven s\u00f3n les classes base (o classe pare). Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # parent class class Bird : def __init__ ( self ): print ( \"Bird is ready\" ) def who_is_this ( self ): print ( \"Bird\" ) def swim ( self ): print ( \"Swim faster\" ) # child class class Penguin ( Bird ): def __init__ ( self ): # call super() function super () . __init__ () print ( \"Penguin is ready\" ) def who_is_this ( self ): print ( \"Penguin\" ) def run ( self ): print ( \"Run faster\" ) peggy = Penguin () peggy . whoisThis () peggy . swim () peggy . run () --- Bird is ready Penguin is ready Penguin Swim faster Run faster En l'anterior programa, la classe Penguin hereda de la classe Bird. La classe derivada hereda el m\u00e8tode swim() , modifica el m\u00e8tode who_is_this() i ext\u00e9n amb un nou m\u00e8tode run() . Utilitzem super().__init__() dins de l' __init()__ per a inicialitzar la classe pare. Encapsulament Podem restringir l\u2019acc\u00e9s a m\u00e8todes i variables, \u00e9s a dir, definir-los com a privats. Aix\u00f2 impedeix que les dades es modifiquen directament accedint als atributs, \u00e9s el que anomenem encapsulament. Definim atributs o m\u00e8todes privats utilitzant el gui\u00f3 baix com a prefix, \u00e9s a dir, simple _ o doble __. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Computer : def __init__ ( self ): self . __maxprice = 900 def sell ( self ): print ( \"Selling Price: {} \" . format ( self . __maxprice )) def setMaxPrice ( self , price ): self . __maxprice = price c = Computer () c . sell () # change the price c . __maxprice = 1000 c . sell () # using setter function c . setMaxPrice ( 1000 ) c . sell () Text Only 1 2 3 4 Eixida Selling Price: 900 Selling Price: 900 Selling Price: 1000 Com vegem, per canviar el valor, hem d\u2019utilitzar una funci\u00f3 modificadora setter , \u00e9s a dir, setMaxPrice (), que pren el preu com a par\u00e0metre. Polimorfisme El polimorfisme \u00e9s la capacitat d\u2019utilitzar una interf\u00edcie comuna (crides amb els mateixos noms) en diferents classes derivades. Suposem que hem de pintar una forma i que hi ha diverses opcions: rectangle, quadrat, cercle, ... Podr\u00edem utilitzar el mateix m\u00e8tode per a pintar qualsevol forma. Aquest concepte s\u2019anomena polimorfisme. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Parrot : def fly ( self ): print ( \"Parrot can fly\" ) def swim ( self ): print ( \"Parrot can't swim\" ) class Penguin : def fly ( self ): print ( \"Penguin can't fly\" ) def swim ( self ): print ( \"Penguin can swim\" ) # common interface def flying_test ( bird ): bird . fly () #instantiate objects blu = Parrot () peggy = Penguin () # passing the object flying_test ( blu ) flying_test ( peggy ) Text Only 1 2 Parrot can fly Penguin can't fly Al programa anterior, hem definit dues classes Parrot i Penguin. Cadascun d'elles t\u00e9 un m\u00e8tode com\u00fa fly(). No obstant aix\u00f2, les seues funcions s\u00f3n diferents. Per utilitzar el polimorfisme, hem creat una interf\u00edcie comuna, \u00e9s a dir, la funci\u00f3 flying_test() que pren com a par\u00e0metre qualsevol objecte i crida al m\u00e8tode fly() de l\u2019objecte. Aix\u00ed, quan passem els objectes blu i peggy a la funci\u00f3 flying_test(), s'executa el m\u00e8tode corresponent a cadascuna. Activitat 14 Defineix una jerarquia de figures amb les classes Figura , Cercle , Triangle , Rectangle i Quadrat . La clase Figura tindr\u00e1 dos m\u00e9todes abstractes area i perimetre , que implementar\u00e1n la resta de classes. La classe figura ser\u00e0 el que s'anomena una interf\u00edcie informal, ja que tots els seus m\u00e8todes s\u00f3n abstractes. Per a definir que s\u00f3n abstractes, simplement utilitzeu la instrucci\u00f3 pass al bloc de la funci\u00f3. Python 1 2 3 def area () -> int : \"\"\"Torna l'\u00e0rea d'una Figura\"\"\" pass El Cercle rebr\u00e1 el radi com a argument al seu constructor, el Triangle el costat i el Rectangle la base i l'altura. Cercle, Triangle i Rectangle heredar\u00e1n de Figura directament. Quadrat heredar\u00e1 de Rectangle, per\u00f2 al constructor sols rebr\u00e1 un argument, el costat. Crea un objecte de cada tipus i imprimeix les seues caracter\u00edstiques. Info En realitat la classe Figura es pot implementar com a una classe interf\u00edcie , on tots els seus m\u00e8todes siguen abstractes. En Python existeixen dos tipus d'interf\u00edcies, formals i informals. Per altra banda, podem declarar els atributs de les classes com a atributs privats i utilitzar els decoradors @property i @ atribut .setter per a indicar els m\u00e8todes getters i setters, que seran p\u00fablics. Fer-ho d'esta forma t\u00e9 alguns avantatges que veurem m\u00e9s endavant.","title":"Programaci\u00f3 oorientada a objectes"},{"location":"unitats/python/teoria/6%20-%20POO/#programacio-orientada-a-objectes-amb-python","text":"\u00c9s un dels paradigmes m\u00e9s populars per resoldre problemes a trav\u00e9s de la programaci\u00f3. Un objecte t\u00e9 dues caracter\u00edstiques: atributs (estat) funcions (comportament) Per exemple: Una persona pot ser un objecte, ja que t\u00e9 les propietats seg\u00fcents: nom, edat com a atributs cantar, ballar com a comportament El concepte de POO a Python se centra en la reutilitzaci\u00f3 de codi. Aquest concepte tamb\u00e9 es coneix com DRY (Don't Repeat Yourself).","title":"Programaci\u00f3 orientada a objectes amb Python"},{"location":"unitats/python/teoria/6%20-%20POO/#classes","text":"Una classe \u00e9s una definici\u00f3 d'un objecte abstracte, que representa algun ent de la realitat al nostre programa. Cont\u00e9 tots els detalls comuns sobre tots els objectes del mateix tipus. L'exemple de classe de lloro pot ser: Python 1 2 class Parrot (): pass Ac\u00ed fem servir la paraula clau class per definir una classe Loro buida.","title":"Classes"},{"location":"unitats/python/teoria/6%20-%20POO/#objectes","text":"Quan es defineix la classe, nom\u00e9s es defineix la descripci\u00f3 de l'objecte. Per tant, no s\u2019assignen recursos per a la seua execuci\u00f3, ni s'assignen valors als seus atributs. Quan este fet es produeix, aleshores tenim un objecte en mem\u00f2ria sobre el que podem actuar. L'exemple d'objecte de classe lloro pot ser: Python 1 obj = Loro () Aqu\u00ed, obj \u00e9s un objecte de la classe Loro. Suposem que tenim detalls de lloros. Ara, podem construir la classe i crear un objecte per a cada lloro. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Parrot : # class attribute species = \"bird\" # instance attribute def __init__ ( self , name , age ): self . name = name self . age = age # instantiate the Parrot class blu = Parrot ( \"Blu\" , 10 ) woo = Parrot ( \"Woo\" , 15 ) # access the class attributes print ( \"Blu is a {} \" . format ( blu . __class__ . species )) print ( \"Woo is also a {} \" . format ( woo . __class__ . species )) # access the instance attributes print ( \" {} is {} years old\" . format ( blu . name , blu . age )) print ( \" {} is {} years old\" . format ( woo . name , woo . age )) --- Eixida Blu is a bird Woo is also a bird Blu is 10 years old Woo is 15 years old Al programa anterior, hem creat una classe Parrot. A continuaci\u00f3, hem definit uns atributs, que prendran valors diferents en la instanciaci\u00f3 d'objectes diferents. Aquests atributs es defineixen dins del m\u00e8tode init de la classe, que \u00e9s el m\u00e8tode inicialitzador que s\u2019executar\u00e0 nom\u00e9s creem objectes. Despr\u00e9s, creem inst\u00e0ncies de la classe Parrot. blu i woo s\u00f3n refer\u00e8ncies (valor) als nostres objectes nous. Podem accedir als atributs de classe mitjan\u00e7ant __class__.species . Els atributs de classe s\u00f3n els mateixos per a totes les inst\u00e0ncies d\u2019una classe. De la mateixa manera, accedim als atributs de la inst\u00e0ncia mitjan\u00e7ant objecte.nom_atribut . Els atributs d\u2019inst\u00e0ncia (valors) s\u00f3n diferents per a cada inst\u00e0ncia d\u2019una classe.","title":"Objectes"},{"location":"unitats/python/teoria/6%20-%20POO/#metodes","text":"S\u00f3n funcions definides dins el cos d'una classe. S'utilitzen per a definir el comportament de l'objecte. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parrot : # instance attributes def __init__ ( self , name , age ): self . name = name self . age = age # instance method def sing ( self , song ): return \" {} sings {} \" . format ( self . name , song ) def dance ( self ): return \" {} is now dancing\" . format ( self . name ) # instantiate the object blu = Parrot ( \"Blu\" , 10 ) # call our instance methods print ( blu . sing ( \"'Happy'\" )) print ( blu . dance ()) --- Blu sings 'Happy' Blu is now dancing Hem definit dos m\u00e8todes sing() i dance(), que s\u00f3n m\u00e8todes d'inst\u00e0ncia, ja que es criden sobre un objecte.","title":"M\u00e8todes"},{"location":"unitats/python/teoria/6%20-%20POO/#herencia","text":"L'her\u00e8ncia \u00e9s una forma de reutilitzar codi sense tindre-lo que reescriure. A\u00e7\u00f2 facilita el manteniment de les aplicacions. Les noves classes s'anomenen classes derivades (o classe filla). La classes de les que deriven s\u00f3n les classes base (o classe pare). Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # parent class class Bird : def __init__ ( self ): print ( \"Bird is ready\" ) def who_is_this ( self ): print ( \"Bird\" ) def swim ( self ): print ( \"Swim faster\" ) # child class class Penguin ( Bird ): def __init__ ( self ): # call super() function super () . __init__ () print ( \"Penguin is ready\" ) def who_is_this ( self ): print ( \"Penguin\" ) def run ( self ): print ( \"Run faster\" ) peggy = Penguin () peggy . whoisThis () peggy . swim () peggy . run () --- Bird is ready Penguin is ready Penguin Swim faster Run faster En l'anterior programa, la classe Penguin hereda de la classe Bird. La classe derivada hereda el m\u00e8tode swim() , modifica el m\u00e8tode who_is_this() i ext\u00e9n amb un nou m\u00e8tode run() . Utilitzem super().__init__() dins de l' __init()__ per a inicialitzar la classe pare.","title":"Her\u00e8ncia"},{"location":"unitats/python/teoria/6%20-%20POO/#encapsulament","text":"Podem restringir l\u2019acc\u00e9s a m\u00e8todes i variables, \u00e9s a dir, definir-los com a privats. Aix\u00f2 impedeix que les dades es modifiquen directament accedint als atributs, \u00e9s el que anomenem encapsulament. Definim atributs o m\u00e8todes privats utilitzant el gui\u00f3 baix com a prefix, \u00e9s a dir, simple _ o doble __. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Computer : def __init__ ( self ): self . __maxprice = 900 def sell ( self ): print ( \"Selling Price: {} \" . format ( self . __maxprice )) def setMaxPrice ( self , price ): self . __maxprice = price c = Computer () c . sell () # change the price c . __maxprice = 1000 c . sell () # using setter function c . setMaxPrice ( 1000 ) c . sell () Text Only 1 2 3 4 Eixida Selling Price: 900 Selling Price: 900 Selling Price: 1000 Com vegem, per canviar el valor, hem d\u2019utilitzar una funci\u00f3 modificadora setter , \u00e9s a dir, setMaxPrice (), que pren el preu com a par\u00e0metre.","title":"Encapsulament"},{"location":"unitats/python/teoria/6%20-%20POO/#polimorfisme","text":"El polimorfisme \u00e9s la capacitat d\u2019utilitzar una interf\u00edcie comuna (crides amb els mateixos noms) en diferents classes derivades. Suposem que hem de pintar una forma i que hi ha diverses opcions: rectangle, quadrat, cercle, ... Podr\u00edem utilitzar el mateix m\u00e8tode per a pintar qualsevol forma. Aquest concepte s\u2019anomena polimorfisme. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Parrot : def fly ( self ): print ( \"Parrot can fly\" ) def swim ( self ): print ( \"Parrot can't swim\" ) class Penguin : def fly ( self ): print ( \"Penguin can't fly\" ) def swim ( self ): print ( \"Penguin can swim\" ) # common interface def flying_test ( bird ): bird . fly () #instantiate objects blu = Parrot () peggy = Penguin () # passing the object flying_test ( blu ) flying_test ( peggy ) Text Only 1 2 Parrot can fly Penguin can't fly Al programa anterior, hem definit dues classes Parrot i Penguin. Cadascun d'elles t\u00e9 un m\u00e8tode com\u00fa fly(). No obstant aix\u00f2, les seues funcions s\u00f3n diferents. Per utilitzar el polimorfisme, hem creat una interf\u00edcie comuna, \u00e9s a dir, la funci\u00f3 flying_test() que pren com a par\u00e0metre qualsevol objecte i crida al m\u00e8tode fly() de l\u2019objecte. Aix\u00ed, quan passem els objectes blu i peggy a la funci\u00f3 flying_test(), s'executa el m\u00e8tode corresponent a cadascuna.","title":"Polimorfisme"},{"location":"unitats/python/teoria/6%20-%20POO/#activitat-14","text":"Defineix una jerarquia de figures amb les classes Figura , Cercle , Triangle , Rectangle i Quadrat . La clase Figura tindr\u00e1 dos m\u00e9todes abstractes area i perimetre , que implementar\u00e1n la resta de classes. La classe figura ser\u00e0 el que s'anomena una interf\u00edcie informal, ja que tots els seus m\u00e8todes s\u00f3n abstractes. Per a definir que s\u00f3n abstractes, simplement utilitzeu la instrucci\u00f3 pass al bloc de la funci\u00f3. Python 1 2 3 def area () -> int : \"\"\"Torna l'\u00e0rea d'una Figura\"\"\" pass El Cercle rebr\u00e1 el radi com a argument al seu constructor, el Triangle el costat i el Rectangle la base i l'altura. Cercle, Triangle i Rectangle heredar\u00e1n de Figura directament. Quadrat heredar\u00e1 de Rectangle, per\u00f2 al constructor sols rebr\u00e1 un argument, el costat. Crea un objecte de cada tipus i imprimeix les seues caracter\u00edstiques. Info En realitat la classe Figura es pot implementar com a una classe interf\u00edcie , on tots els seus m\u00e8todes siguen abstractes. En Python existeixen dos tipus d'interf\u00edcies, formals i informals. Per altra banda, podem declarar els atributs de les classes com a atributs privats i utilitzar els decoradors @property i @ atribut .setter per a indicar els m\u00e8todes getters i setters, que seran p\u00fablics. Fer-ho d'esta forma t\u00e9 alguns avantatges que veurem m\u00e9s endavant.","title":"Activitat 14"}]}